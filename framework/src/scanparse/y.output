Useless nonterminals

   exprs


Terminals which are not used

   COMMA
   NE
   INTTYPE
   FLOATTYPE
   BOOLTYPE


Useless rules

   38 exprs: expr
   39      | expr exprs


Grammar

    0 $accept: fundef $end

    1 fundef: type ID BRACKET_L BRACKET_R funbody

    2 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R

    3 stmts: stmt stmts
    4      | stmt

    5 stmt: assign
    6     | return
    7     | ifelse

    8 return: RETURN expr SEMICOLON

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   10       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R

   11 assign: varlet LET expr SEMICOLON

   12 varlet: ID

   13 expr: constant
   14     | ID
   15     | BRACKET_L expr binop expr BRACKET_R

   16 constant: floatval
   17         | intval
   18         | boolval

   19 floatval: FLOAT

   20 intval: NUM

   21 boolval: TRUEVAL
   22        | FALSEVAL

   23 binop: PLUS
   24      | MINUS
   25      | STAR
   26      | SLASH
   27      | PERCENT
   28      | LE
   29      | LT
   30      | GE
   31      | GT
   32      | EQ
   33      | OR
   34      | AND

   35 type: INT_TYPE
   36     | FLOAT_TYPE
   37     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 35
FLOAT_TYPE (259) 36
BOOL_TYPE (260) 37
BRACKET_L (261) 1 9 10 15
BRACKET_R (262) 1 9 10 15
COMMA (263)
SEMICOLON (264) 8 11
MINUS (265) 24
PLUS (266) 23
STAR (267) 25
SLASH (268) 26
PERCENT (269) 27
LE (270) 28
LT (271) 29
GE (272) 30
GT (273) 31
EQ (274) 32
NE (275)
OR (276) 33
AND (277) 34
TRUEVAL (278) 21
FALSEVAL (279) 22
LET (280) 11
INTTYPE (281)
FLOATTYPE (282)
BOOLTYPE (283)
CURLY_BRACKET_L (284) 2 9 10
CURLY_BRACKET_R (285) 2 9 10
RETURN (286) 8
IF (287) 9 10
ELSE (288) 9 10
NUM (289) 20
FLOAT (290) 19
ID (291) 1 12 14


Nonterminals, with rules where they appear

$accept (37)
    on left: 0
fundef (38)
    on left: 1, on right: 0
funbody (39)
    on left: 2, on right: 1
stmts (40)
    on left: 3 4, on right: 2 3 9
stmt (41)
    on left: 5 6 7, on right: 3 4
return (42)
    on left: 8, on right: 6
ifelse (43)
    on left: 9 10, on right: 7
assign (44)
    on left: 11, on right: 5
varlet (45)
    on left: 12, on right: 11
expr (46)
    on left: 13 14 15, on right: 8 9 10 11 15
constant (47)
    on left: 16 17 18, on right: 13
floatval (48)
    on left: 19, on right: 16
intval (49)
    on left: 20, on right: 17
boolval (50)
    on left: 21 22, on right: 18
binop (51)
    on left: 23 24 25 26 27 28 29 30 31 32 33 34, on right: 15
type (52)
    on left: 35 36 37, on right: 1


state 0

    0 $accept: . fundef $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    fundef  go to state 4
    type    go to state 5


state 1

   35 type: INT_TYPE .

    $default  reduce using rule 35 (type)


state 2

   36 type: FLOAT_TYPE .

    $default  reduce using rule 36 (type)


state 3

   37 type: BOOL_TYPE .

    $default  reduce using rule 37 (type)


state 4

    0 $accept: fundef . $end

    $end  shift, and go to state 6


state 5

    1 fundef: type . ID BRACKET_L BRACKET_R funbody

    ID  shift, and go to state 7


state 6

    0 $accept: fundef $end .

    $default  accept


state 7

    1 fundef: type ID . BRACKET_L BRACKET_R funbody

    BRACKET_L  shift, and go to state 8


state 8

    1 fundef: type ID BRACKET_L . BRACKET_R funbody

    BRACKET_R  shift, and go to state 9


state 9

    1 fundef: type ID BRACKET_L BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 10

    funbody  go to state 11


state 10

    2 funbody: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 12
    IF      shift, and go to state 13
    ID      shift, and go to state 14

    stmts   go to state 15
    stmt    go to state 16
    return  go to state 17
    ifelse  go to state 18
    assign  go to state 19
    varlet  go to state 20


state 11

    1 fundef: type ID BRACKET_L BRACKET_R funbody .

    $default  reduce using rule 1 (fundef)


state 12

    8 return: RETURN . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 27
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 13

    9 ifelse: IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   10       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 32


state 14

   12 varlet: ID .

    $default  reduce using rule 12 (varlet)


state 15

    2 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 33


state 16

    3 stmts: stmt . stmts
    4      | stmt .

    RETURN  shift, and go to state 12
    IF      shift, and go to state 13
    ID      shift, and go to state 14

    $default  reduce using rule 4 (stmts)

    stmts   go to state 34
    stmt    go to state 16
    return  go to state 17
    ifelse  go to state 18
    assign  go to state 19
    varlet  go to state 20


state 17

    6 stmt: return .

    $default  reduce using rule 6 (stmt)


state 18

    7 stmt: ifelse .

    $default  reduce using rule 7 (stmt)


state 19

    5 stmt: assign .

    $default  reduce using rule 5 (stmt)


state 20

   11 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 35


state 21

   15 expr: BRACKET_L . expr binop expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 36
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 22

   21 boolval: TRUEVAL .

    $default  reduce using rule 21 (boolval)


state 23

   22 boolval: FALSEVAL .

    $default  reduce using rule 22 (boolval)


state 24

   20 intval: NUM .

    $default  reduce using rule 20 (intval)


state 25

   19 floatval: FLOAT .

    $default  reduce using rule 19 (floatval)


state 26

   14 expr: ID .

    $default  reduce using rule 14 (expr)


state 27

    8 return: RETURN expr . SEMICOLON

    SEMICOLON  shift, and go to state 37


state 28

   13 expr: constant .

    $default  reduce using rule 13 (expr)


state 29

   16 constant: floatval .

    $default  reduce using rule 16 (constant)


state 30

   17 constant: intval .

    $default  reduce using rule 17 (constant)


state 31

   18 constant: boolval .

    $default  reduce using rule 18 (constant)


state 32

    9 ifelse: IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   10       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 38
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 33

    2 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 2 (funbody)


state 34

    3 stmts: stmt stmts .

    $default  reduce using rule 3 (stmts)


state 35

   11 assign: varlet LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 39
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 36

   15 expr: BRACKET_L expr . binop expr BRACKET_R

    MINUS    shift, and go to state 40
    PLUS     shift, and go to state 41
    STAR     shift, and go to state 42
    SLASH    shift, and go to state 43
    PERCENT  shift, and go to state 44
    LE       shift, and go to state 45
    LT       shift, and go to state 46
    GE       shift, and go to state 47
    GT       shift, and go to state 48
    EQ       shift, and go to state 49
    OR       shift, and go to state 50
    AND      shift, and go to state 51

    binop  go to state 52


state 37

    8 return: RETURN expr SEMICOLON .

    $default  reduce using rule 8 (return)


state 38

    9 ifelse: IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   10       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 53


state 39

   11 assign: varlet LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 54


state 40

   24 binop: MINUS .

    $default  reduce using rule 24 (binop)


state 41

   23 binop: PLUS .

    $default  reduce using rule 23 (binop)


state 42

   25 binop: STAR .

    $default  reduce using rule 25 (binop)


state 43

   26 binop: SLASH .

    $default  reduce using rule 26 (binop)


state 44

   27 binop: PERCENT .

    $default  reduce using rule 27 (binop)


state 45

   28 binop: LE .

    $default  reduce using rule 28 (binop)


state 46

   29 binop: LT .

    $default  reduce using rule 29 (binop)


state 47

   30 binop: GE .

    $default  reduce using rule 30 (binop)


state 48

   31 binop: GT .

    $default  reduce using rule 31 (binop)


state 49

   32 binop: EQ .

    $default  reduce using rule 32 (binop)


state 50

   33 binop: OR .

    $default  reduce using rule 33 (binop)


state 51

   34 binop: AND .

    $default  reduce using rule 34 (binop)


state 52

   15 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 55
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 53

    9 ifelse: IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   10       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 56


state 54

   11 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 11 (assign)


state 55

   15 expr: BRACKET_L expr binop expr . BRACKET_R

    BRACKET_R  shift, and go to state 57


state 56

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   10       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 58
    RETURN           shift, and go to state 12
    IF               shift, and go to state 13
    ID               shift, and go to state 14

    stmts   go to state 59
    stmt    go to state 16
    return  go to state 17
    ifelse  go to state 18
    assign  go to state 19
    varlet  go to state 20


state 57

   15 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 15 (expr)


state 58

   10 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R

    ELSE  shift, and go to state 60


state 59

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 61


state 60

   10 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 62


state 61

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R . ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R

    ELSE  shift, and go to state 63


state 62

   10 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 64


state 63

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 65


state 64

   10 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 10 (ifelse)


state 65

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 12
    IF      shift, and go to state 13
    ID      shift, and go to state 14

    stmts   go to state 66
    stmt    go to state 16
    return  go to state 17
    ifelse  go to state 18
    assign  go to state 19
    varlet  go to state 20


state 66

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 67


state 67

    9 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 9 (ifelse)
