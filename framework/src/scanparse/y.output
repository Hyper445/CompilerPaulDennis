Terminals which are not used

   NE
   NEG
   INTTYPE
   FLOATTYPE
   BOOLTYPE


State 40 conflicts: 1 shift/reduce
State 72 conflicts: 21 reduce/reduce
State 79 conflicts: 1 shift/reduce
State 117 conflicts: 21 reduce/reduce
State 172 conflicts: 1 shift/reduce
State 181 conflicts: 3 shift/reduce
State 182 conflicts: 3 shift/reduce
State 193 conflicts: 3 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decls

    2 decls: decl
    3      | decl decls

    4 decl: fundef
    5     | globdef
    6     | globdecl

    7 globdecl: EXTERN type ID ids SEMICOLON
    8         | EXTERN type ID SEMICOLON

    9 globdef: EXPORT type ID LET expr COMMA exprs SEMICOLON
   10        | EXPORT type ID LET expr SEMICOLON
   11        | EXPORT type ID SEMICOLON
   12        | type ID LET expr COMMA exprs SEMICOLON
   13        | type ID LET expr SEMICOLON
   14        | type ID SEMICOLON

   15 fundef: EXPORT type ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT type ID BRACKET_L BRACKET_R funbody
   17       | EXPORT type ID BRACKET_L param BRACKET_R funbody
   18       | type ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type ID BRACKET_L BRACKET_R funbody
   20       | type ID BRACKET_L param BRACKET_R funbody

   21 param: type ID ids param
   22      | type ID ids
   23      | type ID COMMA param
   24      | type ID

   25 fundefs: fundef fundefs
   26        | fundef

   27 ids: ID ids
   28    | ID

   29 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R
   30        | CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R
   31        | CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R
   32        | CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R
   33        | CURLY_BRACKET_L vardecl CURLY_BRACKET_R
   34        | CURLY_BRACKET_L stmts CURLY_BRACKET_R
   35        | CURLY_BRACKET_L fundefs CURLY_BRACKET_R
   36        | CURLY_BRACKET_L CURLY_BRACKET_R

   37 vardecl: type ID LET exprs expr SEMICOLON vardecl
   38        | type ID LET exprs expr SEMICOLON
   39        | type ID LET exprs SEMICOLON vardecl
   40        | type ID LET expr SEMICOLON vardecl
   41        | type ID LET exprs SEMICOLON
   42        | type ID LET expr SEMICOLON
   43        | type ID LET SEMICOLON vardecl
   44        | type ID SEMICOLON

   45 stmts: stmt stmts
   46      | stmt

   47 stmt: assign
   48     | return
   49     | ifelse
   50     | for
   51     | dowhile
   52     | while
   53     | expr

   54 return: RETURN expr SEMICOLON
   55       | RETURN SEMICOLON

   56 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block
   57       | IF BRACKET_L expr BRACKET_R block
   58       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE block
   60       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

   61 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R

   62 assign: varlet LET expr SEMICOLON

   63 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   67 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

   68 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   69 varlet: ID

   70 expr: constant
   71     | ID
   72     | monop expr
   73     | BRACKET_L expr binop expr BRACKET_R
   74     | cast
   75     | funcall
   76     | arrexpr

   77 cast: BRACKET_L type BRACKET_R expr SEMICOLON

   78 funcall: ID BRACKET_L exprs BRACKET_R SEMICOLON
   79        | ID BRACKET_L BRACKET_R SEMICOLON

   80 arrexpr: SQUARE_BRACKET_L exprs SQUARE_BRACKET_R

   81 exprs: expr
   82      | expr COMMA exprs

   83 constant: floatval
   84         | intval
   85         | boolval

   86 floatval: FLOAT

   87 intval: NUM

   88 boolval: TRUEVAL
   89        | FALSEVAL

   90 binop: PLUS
   91      | MINUS
   92      | STAR
   93      | SLASH
   94      | PERCENT
   95      | LE
   96      | LT
   97      | GE
   98      | GT
   99      | EQ
  100      | OR
  101      | AND

  102 monop: NOT
  103      | MINUS

  104 type: INT_TYPE
  105     | FLOAT_TYPE
  106     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 104
FLOAT_TYPE (259) 105
BOOL_TYPE (260) 106
BRACKET_L (261) 15 16 17 18 19 20 56 57 58 59 60 63 64 65 66 67 68
    73 77 78 79
BRACKET_R (262) 15 16 17 18 19 20 56 57 58 59 60 63 64 65 66 67 68
    73 77 78 79
COMMA (263) 9 12 23 63 64 65 66 82
SEMICOLON (264) 7 8 9 10 11 12 13 14 37 38 39 40 41 42 43 44 54 55
    62 67 77 78 79
MINUS (265) 91 103
PLUS (266) 90
STAR (267) 92
SLASH (268) 93
PERCENT (269) 94
LE (270) 95
LT (271) 96
GE (272) 97
GT (273) 98
EQ (274) 99
NE (275)
OR (276) 100
AND (277) 101
NOT (278) 102
NEG (279)
TRUEVAL (280) 88
FALSEVAL (281) 89
LET (282) 9 10 12 13 37 38 39 40 41 42 43 62 63 64 65 66
INTTYPE (283)
FLOATTYPE (284)
BOOLTYPE (285)
CURLY_BRACKET_L (286) 15 18 29 30 31 32 33 34 35 36 58 59 60 61 63
    64 65 66 67 68
CURLY_BRACKET_R (287) 15 18 29 30 31 32 33 34 35 36 58 59 60 61 63
    64 65 66 67 68
RETURN (288) 54 55
SQUARE_BRACKET_L (289) 80
SQUARE_BRACKET_R (290) 80
EXTERN (291) 7 8
EXPORT (292) 9 10 11 15 16 17
IF (293) 56 57 58 59 60
ELSE (294) 56 58 59
FOR (295) 63 64 65 66
DO (296) 67
WHILE (297) 67 68
NUM (298) 87
FLOAT (299) 86
ID (300) 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 27 28 37
    38 39 40 41 42 43 44 63 64 65 66 69 71 78 79


Nonterminals, with rules where they appear

$accept (46)
    on left: 0
program (47)
    on left: 1, on right: 0
decls (48)
    on left: 2 3, on right: 1 3
decl (49)
    on left: 4 5 6, on right: 2 3
globdecl (50)
    on left: 7 8, on right: 6
globdef (51)
    on left: 9 10 11 12 13 14, on right: 5
fundef (52)
    on left: 15 16 17 18 19 20, on right: 4 25 26
param (53)
    on left: 21 22 23 24, on right: 17 20 21 23
fundefs (54)
    on left: 25 26, on right: 25 29 30 32 35
ids (55)
    on left: 27 28, on right: 7 21 22 27
funbody (56)
    on left: 29 30 31 32 33 34 35 36, on right: 16 17 19 20
vardecl (57)
    on left: 37 38 39 40 41 42 43 44, on right: 29 31 32 33 37 39 40
    43
stmts (58)
    on left: 45 46, on right: 29 30 31 34 45 61 65 66 67 68
stmt (59)
    on left: 47 48 49 50 51 52 53, on right: 45 46
return (60)
    on left: 54 55, on right: 48
ifelse (61)
    on left: 56 57 58 59 60, on right: 49
block (62)
    on left: 61, on right: 56 57 59
assign (63)
    on left: 62, on right: 47
for (64)
    on left: 63 64 65 66, on right: 50
dowhile (65)
    on left: 67, on right: 51
while (66)
    on left: 68, on right: 52
varlet (67)
    on left: 69, on right: 62
expr (68)
    on left: 70 71 72 73 74 75 76, on right: 9 10 12 13 37 38 40 42
    53 54 56 57 58 59 60 62 63 64 65 66 67 68 72 73 77 81 82
cast (69)
    on left: 77, on right: 74
funcall (70)
    on left: 78 79, on right: 75
arrexpr (71)
    on left: 80, on right: 76
exprs (72)
    on left: 81 82, on right: 9 12 37 38 39 41 78 80 82
constant (73)
    on left: 83 84 85, on right: 70
floatval (74)
    on left: 86, on right: 83
intval (75)
    on left: 87, on right: 84
boolval (76)
    on left: 88 89, on right: 85
binop (77)
    on left: 90 91 92 93 94 95 96 97 98 99 100 101,
    on right: 73
monop (78)
    on left: 102 103, on right: 72
type (79)
    on left: 104 105 106, on right: 7 8 9 10 11 12 13 14 15 16 17 18
    19 20 21 22 23 24 37 38 39 40 41 42 43 44 63 64 65 66 77


state 0

    0 $accept: . program $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    EXTERN      shift, and go to state 4
    EXPORT      shift, and go to state 5

    program   go to state 6
    decls     go to state 7
    decl      go to state 8
    globdecl  go to state 9
    globdef   go to state 10
    fundef    go to state 11
    type      go to state 12


state 1

  104 type: INT_TYPE .

    $default  reduce using rule 104 (type)


state 2

  105 type: FLOAT_TYPE .

    $default  reduce using rule 105 (type)


state 3

  106 type: BOOL_TYPE .

    $default  reduce using rule 106 (type)


state 4

    7 globdecl: EXTERN . type ID ids SEMICOLON
    8         | EXTERN . type ID SEMICOLON

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 13


state 5

    9 globdef: EXPORT . type ID LET expr COMMA exprs SEMICOLON
   10        | EXPORT . type ID LET expr SEMICOLON
   11        | EXPORT . type ID SEMICOLON
   15 fundef: EXPORT . type ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT . type ID BRACKET_L BRACKET_R funbody
   17       | EXPORT . type ID BRACKET_L param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 14


state 6

    0 $accept: program . $end

    $end  shift, and go to state 15


state 7

    1 program: decls .

    $default  reduce using rule 1 (program)


state 8

    2 decls: decl .
    3      | decl . decls

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    EXTERN      shift, and go to state 4
    EXPORT      shift, and go to state 5

    $default  reduce using rule 2 (decls)

    decls     go to state 16
    decl      go to state 8
    globdecl  go to state 9
    globdef   go to state 10
    fundef    go to state 11
    type      go to state 12


state 9

    6 decl: globdecl .

    $default  reduce using rule 6 (decl)


state 10

    5 decl: globdef .

    $default  reduce using rule 5 (decl)


state 11

    4 decl: fundef .

    $default  reduce using rule 4 (decl)


state 12

   12 globdef: type . ID LET expr COMMA exprs SEMICOLON
   13        | type . ID LET expr SEMICOLON
   14        | type . ID SEMICOLON
   18 fundef: type . ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type . ID BRACKET_L BRACKET_R funbody
   20       | type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 17


state 13

    7 globdecl: EXTERN type . ID ids SEMICOLON
    8         | EXTERN type . ID SEMICOLON

    ID  shift, and go to state 18


state 14

    9 globdef: EXPORT type . ID LET expr COMMA exprs SEMICOLON
   10        | EXPORT type . ID LET expr SEMICOLON
   11        | EXPORT type . ID SEMICOLON
   15 fundef: EXPORT type . ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT type . ID BRACKET_L BRACKET_R funbody
   17       | EXPORT type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 19


state 15

    0 $accept: program $end .

    $default  accept


state 16

    3 decls: decl decls .

    $default  reduce using rule 3 (decls)


state 17

   12 globdef: type ID . LET expr COMMA exprs SEMICOLON
   13        | type ID . LET expr SEMICOLON
   14        | type ID . SEMICOLON
   18 fundef: type ID . BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type ID . BRACKET_L BRACKET_R funbody
   20       | type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 20
    SEMICOLON  shift, and go to state 21
    LET        shift, and go to state 22


state 18

    7 globdecl: EXTERN type ID . ids SEMICOLON
    8         | EXTERN type ID . SEMICOLON

    SEMICOLON  shift, and go to state 23
    ID         shift, and go to state 24

    ids  go to state 25


state 19

    9 globdef: EXPORT type ID . LET expr COMMA exprs SEMICOLON
   10        | EXPORT type ID . LET expr SEMICOLON
   11        | EXPORT type ID . SEMICOLON
   15 fundef: EXPORT type ID . BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT type ID . BRACKET_L BRACKET_R funbody
   17       | EXPORT type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 26
    SEMICOLON  shift, and go to state 27
    LET        shift, and go to state 28


state 20

   18 fundef: type ID BRACKET_L . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type ID BRACKET_L . BRACKET_R funbody
   20       | type ID BRACKET_L . param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    BRACKET_R   shift, and go to state 29

    param  go to state 30
    type   go to state 31


state 21

   14 globdef: type ID SEMICOLON .

    $default  reduce using rule 14 (globdef)


state 22

   12 globdef: type ID LET . expr COMMA exprs SEMICOLON
   13        | type ID LET . expr SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 41
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 23

    8 globdecl: EXTERN type ID SEMICOLON .

    $default  reduce using rule 8 (globdecl)


state 24

   27 ids: ID . ids
   28    | ID .

    ID  shift, and go to state 24

    $default  reduce using rule 28 (ids)

    ids  go to state 50


state 25

    7 globdecl: EXTERN type ID ids . SEMICOLON

    SEMICOLON  shift, and go to state 51


state 26

   15 fundef: EXPORT type ID BRACKET_L . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT type ID BRACKET_L . BRACKET_R funbody
   17       | EXPORT type ID BRACKET_L . param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    BRACKET_R   shift, and go to state 52

    param  go to state 53
    type   go to state 31


state 27

   11 globdef: EXPORT type ID SEMICOLON .

    $default  reduce using rule 11 (globdef)


state 28

    9 globdef: EXPORT type ID LET . expr COMMA exprs SEMICOLON
   10        | EXPORT type ID LET . expr SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 54
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 29

   18 fundef: type ID BRACKET_L BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type ID BRACKET_L BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 55

    funbody  go to state 56


state 30

   20 fundef: type ID BRACKET_L param . BRACKET_R funbody

    BRACKET_R  shift, and go to state 57


state 31

   21 param: type . ID ids param
   22      | type . ID ids
   23      | type . ID COMMA param
   24      | type . ID

    ID  shift, and go to state 58


state 32

   73 expr: BRACKET_L . expr binop expr BRACKET_R
   77 cast: BRACKET_L . type BRACKET_R expr SEMICOLON

    INT_TYPE          shift, and go to state 1
    FLOAT_TYPE        shift, and go to state 2
    BOOL_TYPE         shift, and go to state 3
    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 59
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49
    type      go to state 60


state 33

  103 monop: MINUS .

    $default  reduce using rule 103 (monop)


state 34

  102 monop: NOT .

    $default  reduce using rule 102 (monop)


state 35

   88 boolval: TRUEVAL .

    $default  reduce using rule 88 (boolval)


state 36

   89 boolval: FALSEVAL .

    $default  reduce using rule 89 (boolval)


state 37

   80 arrexpr: SQUARE_BRACKET_L . exprs SQUARE_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 61
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    exprs     go to state 62
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 38

   87 intval: NUM .

    $default  reduce using rule 87 (intval)


state 39

   86 floatval: FLOAT .

    $default  reduce using rule 86 (floatval)


state 40

   71 expr: ID .
   78 funcall: ID . BRACKET_L exprs BRACKET_R SEMICOLON
   79        | ID . BRACKET_L BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 63

    BRACKET_L  [reduce using rule 71 (expr)]
    $default   reduce using rule 71 (expr)


state 41

   12 globdef: type ID LET expr . COMMA exprs SEMICOLON
   13        | type ID LET expr . SEMICOLON

    COMMA      shift, and go to state 64
    SEMICOLON  shift, and go to state 65


state 42

   74 expr: cast .

    $default  reduce using rule 74 (expr)


state 43

   75 expr: funcall .

    $default  reduce using rule 75 (expr)


state 44

   76 expr: arrexpr .

    $default  reduce using rule 76 (expr)


state 45

   70 expr: constant .

    $default  reduce using rule 70 (expr)


state 46

   83 constant: floatval .

    $default  reduce using rule 83 (constant)


state 47

   84 constant: intval .

    $default  reduce using rule 84 (constant)


state 48

   85 constant: boolval .

    $default  reduce using rule 85 (constant)


state 49

   72 expr: monop . expr

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 66
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 50

   27 ids: ID ids .

    $default  reduce using rule 27 (ids)


state 51

    7 globdecl: EXTERN type ID ids SEMICOLON .

    $default  reduce using rule 7 (globdecl)


state 52

   15 fundef: EXPORT type ID BRACKET_L BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT type ID BRACKET_L BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 67

    funbody  go to state 68


state 53

   17 fundef: EXPORT type ID BRACKET_L param . BRACKET_R funbody

    BRACKET_R  shift, and go to state 69


state 54

    9 globdef: EXPORT type ID LET expr . COMMA exprs SEMICOLON
   10        | EXPORT type ID LET expr . SEMICOLON

    COMMA      shift, and go to state 70
    SEMICOLON  shift, and go to state 71


state 55

   18 fundef: type ID BRACKET_L BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   29 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   30        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   31        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   32        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   33        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   34        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   35        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   36        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE          shift, and go to state 1
    FLOAT_TYPE        shift, and go to state 2
    BOOL_TYPE         shift, and go to state 3
    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 72
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    EXPORT            shift, and go to state 74
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    fundef    go to state 80
    fundefs   go to state 81
    vardecl   go to state 82
    stmts     go to state 83
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49
    type      go to state 93


state 56

   19 fundef: type ID BRACKET_L BRACKET_R funbody .

    $default  reduce using rule 19 (fundef)


state 57

   20 fundef: type ID BRACKET_L param BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 94

    funbody  go to state 95


state 58

   21 param: type ID . ids param
   22      | type ID . ids
   23      | type ID . COMMA param
   24      | type ID .

    COMMA  shift, and go to state 96
    ID     shift, and go to state 24

    $default  reduce using rule 24 (param)

    ids  go to state 97


state 59

   73 expr: BRACKET_L expr . binop expr BRACKET_R

    MINUS    shift, and go to state 98
    PLUS     shift, and go to state 99
    STAR     shift, and go to state 100
    SLASH    shift, and go to state 101
    PERCENT  shift, and go to state 102
    LE       shift, and go to state 103
    LT       shift, and go to state 104
    GE       shift, and go to state 105
    GT       shift, and go to state 106
    EQ       shift, and go to state 107
    OR       shift, and go to state 108
    AND      shift, and go to state 109

    binop  go to state 110


state 60

   77 cast: BRACKET_L type . BRACKET_R expr SEMICOLON

    BRACKET_R  shift, and go to state 111


state 61

   81 exprs: expr .
   82      | expr . COMMA exprs

    COMMA  shift, and go to state 112

    $default  reduce using rule 81 (exprs)


state 62

   80 arrexpr: SQUARE_BRACKET_L exprs . SQUARE_BRACKET_R

    SQUARE_BRACKET_R  shift, and go to state 113


state 63

   78 funcall: ID BRACKET_L . exprs BRACKET_R SEMICOLON
   79        | ID BRACKET_L . BRACKET_R SEMICOLON

    BRACKET_L         shift, and go to state 32
    BRACKET_R         shift, and go to state 114
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 61
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    exprs     go to state 115
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 64

   12 globdef: type ID LET expr COMMA . exprs SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 61
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    exprs     go to state 116
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 65

   13 globdef: type ID LET expr SEMICOLON .

    $default  reduce using rule 13 (globdef)


state 66

   72 expr: monop expr .

    $default  reduce using rule 72 (expr)


state 67

   15 fundef: EXPORT type ID BRACKET_L BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   29 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   30        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   31        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   32        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   33        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   34        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   35        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   36        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE          shift, and go to state 1
    FLOAT_TYPE        shift, and go to state 2
    BOOL_TYPE         shift, and go to state 3
    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 117
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    EXPORT            shift, and go to state 74
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    fundef    go to state 80
    fundefs   go to state 81
    vardecl   go to state 82
    stmts     go to state 83
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49
    type      go to state 93


state 68

   16 fundef: EXPORT type ID BRACKET_L BRACKET_R funbody .

    $default  reduce using rule 16 (fundef)


state 69

   17 fundef: EXPORT type ID BRACKET_L param BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 94

    funbody  go to state 118


state 70

    9 globdef: EXPORT type ID LET expr COMMA . exprs SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 61
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    exprs     go to state 119
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 71

   10 globdef: EXPORT type ID LET expr SEMICOLON .

    $default  reduce using rule 10 (globdef)


state 72

   18 fundef: type ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .
   36 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $end              reduce using rule 18 (fundef)
    $end              [reduce using rule 36 (funbody)]
    INT_TYPE          reduce using rule 18 (fundef)
    INT_TYPE          [reduce using rule 36 (funbody)]
    FLOAT_TYPE        reduce using rule 18 (fundef)
    FLOAT_TYPE        [reduce using rule 36 (funbody)]
    BOOL_TYPE         reduce using rule 18 (fundef)
    BOOL_TYPE         [reduce using rule 36 (funbody)]
    BRACKET_L         reduce using rule 18 (fundef)
    BRACKET_L         [reduce using rule 36 (funbody)]
    MINUS             reduce using rule 18 (fundef)
    MINUS             [reduce using rule 36 (funbody)]
    NOT               reduce using rule 18 (fundef)
    NOT               [reduce using rule 36 (funbody)]
    TRUEVAL           reduce using rule 18 (fundef)
    TRUEVAL           [reduce using rule 36 (funbody)]
    FALSEVAL          reduce using rule 18 (fundef)
    FALSEVAL          [reduce using rule 36 (funbody)]
    CURLY_BRACKET_R   reduce using rule 18 (fundef)
    CURLY_BRACKET_R   [reduce using rule 36 (funbody)]
    RETURN            reduce using rule 18 (fundef)
    RETURN            [reduce using rule 36 (funbody)]
    SQUARE_BRACKET_L  reduce using rule 18 (fundef)
    SQUARE_BRACKET_L  [reduce using rule 36 (funbody)]
    EXTERN            reduce using rule 18 (fundef)
    EXTERN            [reduce using rule 36 (funbody)]
    EXPORT            reduce using rule 18 (fundef)
    EXPORT            [reduce using rule 36 (funbody)]
    IF                reduce using rule 18 (fundef)
    IF                [reduce using rule 36 (funbody)]
    FOR               reduce using rule 18 (fundef)
    FOR               [reduce using rule 36 (funbody)]
    DO                reduce using rule 18 (fundef)
    DO                [reduce using rule 36 (funbody)]
    WHILE             reduce using rule 18 (fundef)
    WHILE             [reduce using rule 36 (funbody)]
    NUM               reduce using rule 18 (fundef)
    NUM               [reduce using rule 36 (funbody)]
    FLOAT             reduce using rule 18 (fundef)
    FLOAT             [reduce using rule 36 (funbody)]
    ID                reduce using rule 18 (fundef)
    ID                [reduce using rule 36 (funbody)]
    $default          reduce using rule 18 (fundef)


state 73

   54 return: RETURN . expr SEMICOLON
   55       | RETURN . SEMICOLON

    BRACKET_L         shift, and go to state 32
    SEMICOLON         shift, and go to state 120
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 121
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 74

   15 fundef: EXPORT . type ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT . type ID BRACKET_L BRACKET_R funbody
   17       | EXPORT . type ID BRACKET_L param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 122


state 75

   56 ifelse: IF . BRACKET_L expr BRACKET_R block ELSE block
   57       | IF . BRACKET_L expr BRACKET_R block
   58       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE block
   60       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 123


state 76

   63 for: FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 124


state 77

   67 dowhile: DO . CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_L  shift, and go to state 125


state 78

   68 while: WHILE . BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 126


state 79

   69 varlet: ID .
   71 expr: ID .
   78 funcall: ID . BRACKET_L exprs BRACKET_R SEMICOLON
   79        | ID . BRACKET_L BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 63

    BRACKET_L  [reduce using rule 71 (expr)]
    LET        reduce using rule 69 (varlet)
    $default   reduce using rule 71 (expr)


state 80

   25 fundefs: fundef . fundefs
   26        | fundef .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    EXPORT      shift, and go to state 74

    $default  reduce using rule 26 (fundefs)

    fundef   go to state 80
    fundefs  go to state 127
    type     go to state 128


state 81

   30 funbody: CURLY_BRACKET_L fundefs . stmts CURLY_BRACKET_R
   35        | CURLY_BRACKET_L fundefs . CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 129
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 130
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 82

   29 funbody: CURLY_BRACKET_L vardecl . fundefs stmts CURLY_BRACKET_R
   31        | CURLY_BRACKET_L vardecl . stmts CURLY_BRACKET_R
   32        | CURLY_BRACKET_L vardecl . fundefs CURLY_BRACKET_R
   33        | CURLY_BRACKET_L vardecl . CURLY_BRACKET_R

    INT_TYPE          shift, and go to state 1
    FLOAT_TYPE        shift, and go to state 2
    BOOL_TYPE         shift, and go to state 3
    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 131
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    EXPORT            shift, and go to state 74
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    fundef    go to state 80
    fundefs   go to state 132
    stmts     go to state 133
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49
    type      go to state 128


state 83

   34 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 134


state 84

   45 stmts: stmt . stmts
   46      | stmt .

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    $default  reduce using rule 46 (stmts)

    stmts     go to state 135
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 85

   48 stmt: return .

    $default  reduce using rule 48 (stmt)


state 86

   49 stmt: ifelse .

    $default  reduce using rule 49 (stmt)


state 87

   47 stmt: assign .

    $default  reduce using rule 47 (stmt)


state 88

   50 stmt: for .

    $default  reduce using rule 50 (stmt)


state 89

   51 stmt: dowhile .

    $default  reduce using rule 51 (stmt)


state 90

   52 stmt: while .

    $default  reduce using rule 52 (stmt)


state 91

   62 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 136


state 92

   53 stmt: expr .

    $default  reduce using rule 53 (stmt)


state 93

   18 fundef: type . ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type . ID BRACKET_L BRACKET_R funbody
   20       | type . ID BRACKET_L param BRACKET_R funbody
   37 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   38        | type . ID LET exprs expr SEMICOLON
   39        | type . ID LET exprs SEMICOLON vardecl
   40        | type . ID LET expr SEMICOLON vardecl
   41        | type . ID LET exprs SEMICOLON
   42        | type . ID LET expr SEMICOLON
   43        | type . ID LET SEMICOLON vardecl
   44        | type . ID SEMICOLON

    ID  shift, and go to state 137


state 94

   29 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   30        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   31        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   32        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   33        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   34        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   35        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   36        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE          shift, and go to state 1
    FLOAT_TYPE        shift, and go to state 2
    BOOL_TYPE         shift, and go to state 3
    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 138
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    EXPORT            shift, and go to state 74
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    fundef    go to state 80
    fundefs   go to state 81
    vardecl   go to state 82
    stmts     go to state 83
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49
    type      go to state 93


state 95

   20 fundef: type ID BRACKET_L param BRACKET_R funbody .

    $default  reduce using rule 20 (fundef)


state 96

   23 param: type ID COMMA . param

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 139
    type   go to state 31


state 97

   21 param: type ID ids . param
   22      | type ID ids .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 22 (param)

    param  go to state 140
    type   go to state 31


state 98

   91 binop: MINUS .

    $default  reduce using rule 91 (binop)


state 99

   90 binop: PLUS .

    $default  reduce using rule 90 (binop)


state 100

   92 binop: STAR .

    $default  reduce using rule 92 (binop)


state 101

   93 binop: SLASH .

    $default  reduce using rule 93 (binop)


state 102

   94 binop: PERCENT .

    $default  reduce using rule 94 (binop)


state 103

   95 binop: LE .

    $default  reduce using rule 95 (binop)


state 104

   96 binop: LT .

    $default  reduce using rule 96 (binop)


state 105

   97 binop: GE .

    $default  reduce using rule 97 (binop)


state 106

   98 binop: GT .

    $default  reduce using rule 98 (binop)


state 107

   99 binop: EQ .

    $default  reduce using rule 99 (binop)


state 108

  100 binop: OR .

    $default  reduce using rule 100 (binop)


state 109

  101 binop: AND .

    $default  reduce using rule 101 (binop)


state 110

   73 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 141
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 111

   77 cast: BRACKET_L type BRACKET_R . expr SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 142
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 112

   82 exprs: expr COMMA . exprs

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 61
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    exprs     go to state 143
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 113

   80 arrexpr: SQUARE_BRACKET_L exprs SQUARE_BRACKET_R .

    $default  reduce using rule 80 (arrexpr)


state 114

   79 funcall: ID BRACKET_L BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 144


state 115

   78 funcall: ID BRACKET_L exprs . BRACKET_R SEMICOLON

    BRACKET_R  shift, and go to state 145


state 116

   12 globdef: type ID LET expr COMMA exprs . SEMICOLON

    SEMICOLON  shift, and go to state 146


state 117

   15 fundef: EXPORT type ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .
   36 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $end              reduce using rule 15 (fundef)
    $end              [reduce using rule 36 (funbody)]
    INT_TYPE          reduce using rule 15 (fundef)
    INT_TYPE          [reduce using rule 36 (funbody)]
    FLOAT_TYPE        reduce using rule 15 (fundef)
    FLOAT_TYPE        [reduce using rule 36 (funbody)]
    BOOL_TYPE         reduce using rule 15 (fundef)
    BOOL_TYPE         [reduce using rule 36 (funbody)]
    BRACKET_L         reduce using rule 15 (fundef)
    BRACKET_L         [reduce using rule 36 (funbody)]
    MINUS             reduce using rule 15 (fundef)
    MINUS             [reduce using rule 36 (funbody)]
    NOT               reduce using rule 15 (fundef)
    NOT               [reduce using rule 36 (funbody)]
    TRUEVAL           reduce using rule 15 (fundef)
    TRUEVAL           [reduce using rule 36 (funbody)]
    FALSEVAL          reduce using rule 15 (fundef)
    FALSEVAL          [reduce using rule 36 (funbody)]
    CURLY_BRACKET_R   reduce using rule 15 (fundef)
    CURLY_BRACKET_R   [reduce using rule 36 (funbody)]
    RETURN            reduce using rule 15 (fundef)
    RETURN            [reduce using rule 36 (funbody)]
    SQUARE_BRACKET_L  reduce using rule 15 (fundef)
    SQUARE_BRACKET_L  [reduce using rule 36 (funbody)]
    EXTERN            reduce using rule 15 (fundef)
    EXTERN            [reduce using rule 36 (funbody)]
    EXPORT            reduce using rule 15 (fundef)
    EXPORT            [reduce using rule 36 (funbody)]
    IF                reduce using rule 15 (fundef)
    IF                [reduce using rule 36 (funbody)]
    FOR               reduce using rule 15 (fundef)
    FOR               [reduce using rule 36 (funbody)]
    DO                reduce using rule 15 (fundef)
    DO                [reduce using rule 36 (funbody)]
    WHILE             reduce using rule 15 (fundef)
    WHILE             [reduce using rule 36 (funbody)]
    NUM               reduce using rule 15 (fundef)
    NUM               [reduce using rule 36 (funbody)]
    FLOAT             reduce using rule 15 (fundef)
    FLOAT             [reduce using rule 36 (funbody)]
    ID                reduce using rule 15 (fundef)
    ID                [reduce using rule 36 (funbody)]
    $default          reduce using rule 15 (fundef)


state 118

   17 fundef: EXPORT type ID BRACKET_L param BRACKET_R funbody .

    $default  reduce using rule 17 (fundef)


state 119

    9 globdef: EXPORT type ID LET expr COMMA exprs . SEMICOLON

    SEMICOLON  shift, and go to state 147


state 120

   55 return: RETURN SEMICOLON .

    $default  reduce using rule 55 (return)


state 121

   54 return: RETURN expr . SEMICOLON

    SEMICOLON  shift, and go to state 148


state 122

   15 fundef: EXPORT type . ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT type . ID BRACKET_L BRACKET_R funbody
   17       | EXPORT type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 149


state 123

   56 ifelse: IF BRACKET_L . expr BRACKET_R block ELSE block
   57       | IF BRACKET_L . expr BRACKET_R block
   58       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE block
   60       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 150
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 124

   63 for: FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 151


state 125

   67 dowhile: DO CURLY_BRACKET_L . stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 152
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 126

   68 while: WHILE BRACKET_L . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 153
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 127

   25 fundefs: fundef fundefs .

    $default  reduce using rule 25 (fundefs)


state 128

   18 fundef: type . ID BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type . ID BRACKET_L BRACKET_R funbody
   20       | type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 154


state 129

   35 funbody: CURLY_BRACKET_L fundefs CURLY_BRACKET_R .

    $default  reduce using rule 35 (funbody)


state 130

   30 funbody: CURLY_BRACKET_L fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 155


state 131

   33 funbody: CURLY_BRACKET_L vardecl CURLY_BRACKET_R .

    $default  reduce using rule 33 (funbody)


state 132

   29 funbody: CURLY_BRACKET_L vardecl fundefs . stmts CURLY_BRACKET_R
   32        | CURLY_BRACKET_L vardecl fundefs . CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 156
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 157
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 133

   31 funbody: CURLY_BRACKET_L vardecl stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 158


state 134

   34 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 34 (funbody)


state 135

   45 stmts: stmt stmts .

    $default  reduce using rule 45 (stmts)


state 136

   62 assign: varlet LET . expr SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 159
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 137

   18 fundef: type ID . BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type ID . BRACKET_L BRACKET_R funbody
   20       | type ID . BRACKET_L param BRACKET_R funbody
   37 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   38        | type ID . LET exprs expr SEMICOLON
   39        | type ID . LET exprs SEMICOLON vardecl
   40        | type ID . LET expr SEMICOLON vardecl
   41        | type ID . LET exprs SEMICOLON
   42        | type ID . LET expr SEMICOLON
   43        | type ID . LET SEMICOLON vardecl
   44        | type ID . SEMICOLON

    BRACKET_L  shift, and go to state 20
    SEMICOLON  shift, and go to state 160
    LET        shift, and go to state 161


state 138

   36 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 36 (funbody)


state 139

   23 param: type ID COMMA param .

    $default  reduce using rule 23 (param)


state 140

   21 param: type ID ids param .

    $default  reduce using rule 21 (param)


state 141

   73 expr: BRACKET_L expr binop expr . BRACKET_R

    BRACKET_R  shift, and go to state 162


state 142

   77 cast: BRACKET_L type BRACKET_R expr . SEMICOLON

    SEMICOLON  shift, and go to state 163


state 143

   82 exprs: expr COMMA exprs .

    $default  reduce using rule 82 (exprs)


state 144

   79 funcall: ID BRACKET_L BRACKET_R SEMICOLON .

    $default  reduce using rule 79 (funcall)


state 145

   78 funcall: ID BRACKET_L exprs BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 164


state 146

   12 globdef: type ID LET expr COMMA exprs SEMICOLON .

    $default  reduce using rule 12 (globdef)


state 147

    9 globdef: EXPORT type ID LET expr COMMA exprs SEMICOLON .

    $default  reduce using rule 9 (globdef)


state 148

   54 return: RETURN expr SEMICOLON .

    $default  reduce using rule 54 (return)


state 149

   15 fundef: EXPORT type ID . BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   16       | EXPORT type ID . BRACKET_L BRACKET_R funbody
   17       | EXPORT type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 26


state 150

   56 ifelse: IF BRACKET_L expr . BRACKET_R block ELSE block
   57       | IF BRACKET_L expr . BRACKET_R block
   58       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE block
   60       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 165


state 151

   63 for: FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    ID  shift, and go to state 166


state 152

   67 dowhile: DO CURLY_BRACKET_L stmts . CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_R  shift, and go to state 167


state 153

   68 while: WHILE BRACKET_L expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 168


state 154

   18 fundef: type ID . BRACKET_L BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   19       | type ID . BRACKET_L BRACKET_R funbody
   20       | type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 20


state 155

   30 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 30 (funbody)


state 156

   32 funbody: CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R .

    $default  reduce using rule 32 (funbody)


state 157

   29 funbody: CURLY_BRACKET_L vardecl fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 169


state 158

   31 funbody: CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R .

    $default  reduce using rule 31 (funbody)


state 159

   62 assign: varlet LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 170


state 160

   44 vardecl: type ID SEMICOLON .

    $default  reduce using rule 44 (vardecl)


state 161

   37 vardecl: type ID LET . exprs expr SEMICOLON vardecl
   38        | type ID LET . exprs expr SEMICOLON
   39        | type ID LET . exprs SEMICOLON vardecl
   40        | type ID LET . expr SEMICOLON vardecl
   41        | type ID LET . exprs SEMICOLON
   42        | type ID LET . expr SEMICOLON
   43        | type ID LET . SEMICOLON vardecl

    BRACKET_L         shift, and go to state 32
    SEMICOLON         shift, and go to state 171
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 172
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    exprs     go to state 173
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 162

   73 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 73 (expr)


state 163

   77 cast: BRACKET_L type BRACKET_R expr SEMICOLON .

    $default  reduce using rule 77 (cast)


state 164

   78 funcall: ID BRACKET_L exprs BRACKET_R SEMICOLON .

    $default  reduce using rule 78 (funcall)


state 165

   56 ifelse: IF BRACKET_L expr BRACKET_R . block ELSE block
   57       | IF BRACKET_L expr BRACKET_R . block
   58       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE block
   60       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 174

    block  go to state 175


state 166

   63 for: FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    LET  shift, and go to state 176


state 167

   67 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R . WHILE BRACKET_L expr BRACKET_R SEMICOLON

    WHILE  shift, and go to state 177


state 168

   68 while: WHILE BRACKET_L expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 178


state 169

   29 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 29 (funbody)


state 170

   62 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 62 (assign)


state 171

   43 vardecl: type ID LET SEMICOLON . vardecl

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    vardecl  go to state 179
    type     go to state 180


state 172

   40 vardecl: type ID LET expr . SEMICOLON vardecl
   42        | type ID LET expr . SEMICOLON
   81 exprs: expr .
   82      | expr . COMMA exprs

    COMMA      shift, and go to state 112
    SEMICOLON  shift, and go to state 181

    SEMICOLON  [reduce using rule 81 (exprs)]
    $default   reduce using rule 81 (exprs)


state 173

   37 vardecl: type ID LET exprs . expr SEMICOLON vardecl
   38        | type ID LET exprs . expr SEMICOLON
   39        | type ID LET exprs . SEMICOLON vardecl
   41        | type ID LET exprs . SEMICOLON

    BRACKET_L         shift, and go to state 32
    SEMICOLON         shift, and go to state 182
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 183
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 174

   58 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE block
   60       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   61 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 184
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 185
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 175

   56 ifelse: IF BRACKET_L expr BRACKET_R block . ELSE block
   57       | IF BRACKET_L expr BRACKET_R block .

    ELSE  shift, and go to state 186

    $default  reduce using rule 57 (ifelse)


state 176

   63 for: FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 187
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 177

   67 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE . BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 188


state 178

   68 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 189
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 179

   43 vardecl: type ID LET SEMICOLON vardecl .

    $default  reduce using rule 43 (vardecl)


state 180

   37 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   38        | type . ID LET exprs expr SEMICOLON
   39        | type . ID LET exprs SEMICOLON vardecl
   40        | type . ID LET expr SEMICOLON vardecl
   41        | type . ID LET exprs SEMICOLON
   42        | type . ID LET expr SEMICOLON
   43        | type . ID LET SEMICOLON vardecl
   44        | type . ID SEMICOLON

    ID  shift, and go to state 190


state 181

   40 vardecl: type ID LET expr SEMICOLON . vardecl
   42        | type ID LET expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 42 (vardecl)]
    FLOAT_TYPE  [reduce using rule 42 (vardecl)]
    BOOL_TYPE   [reduce using rule 42 (vardecl)]
    $default    reduce using rule 42 (vardecl)

    vardecl  go to state 191
    type     go to state 180


state 182

   39 vardecl: type ID LET exprs SEMICOLON . vardecl
   41        | type ID LET exprs SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 41 (vardecl)]
    FLOAT_TYPE  [reduce using rule 41 (vardecl)]
    BOOL_TYPE   [reduce using rule 41 (vardecl)]
    $default    reduce using rule 41 (vardecl)

    vardecl  go to state 192
    type     go to state 180


state 183

   37 vardecl: type ID LET exprs expr . SEMICOLON vardecl
   38        | type ID LET exprs expr . SEMICOLON

    SEMICOLON  shift, and go to state 193


state 184

   58 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE block
   60       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    ELSE  shift, and go to state 194

    $default  reduce using rule 60 (ifelse)


state 185

   61 block: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 195


state 186

   56 ifelse: IF BRACKET_L expr BRACKET_R block ELSE . block

    CURLY_BRACKET_L  shift, and go to state 196

    block  go to state 197


state 187

   63 for: FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    COMMA  shift, and go to state 198


state 188

   67 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L . expr BRACKET_R SEMICOLON

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 199
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 189

   68 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 200


state 190

   37 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   38        | type ID . LET exprs expr SEMICOLON
   39        | type ID . LET exprs SEMICOLON vardecl
   40        | type ID . LET expr SEMICOLON vardecl
   41        | type ID . LET exprs SEMICOLON
   42        | type ID . LET expr SEMICOLON
   43        | type ID . LET SEMICOLON vardecl
   44        | type ID . SEMICOLON

    SEMICOLON  shift, and go to state 160
    LET        shift, and go to state 161


state 191

   40 vardecl: type ID LET expr SEMICOLON vardecl .

    $default  reduce using rule 40 (vardecl)


state 192

   39 vardecl: type ID LET exprs SEMICOLON vardecl .

    $default  reduce using rule 39 (vardecl)


state 193

   37 vardecl: type ID LET exprs expr SEMICOLON . vardecl
   38        | type ID LET exprs expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 38 (vardecl)]
    FLOAT_TYPE  [reduce using rule 38 (vardecl)]
    BOOL_TYPE   [reduce using rule 38 (vardecl)]
    $default    reduce using rule 38 (vardecl)

    vardecl  go to state 201
    type     go to state 180


state 194

   58 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R
   59       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . block

    CURLY_BRACKET_L  shift, and go to state 202

    block  go to state 203


state 195

   61 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 61 (block)


state 196

   61 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 185
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 197

   56 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block .

    $default  reduce using rule 56 (ifelse)


state 198

   63 for: FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 204
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 199

   67 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr . BRACKET_R SEMICOLON

    BRACKET_R  shift, and go to state 205


state 200

   68 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 68 (while)


state 201

   37 vardecl: type ID LET exprs expr SEMICOLON vardecl .

    $default  reduce using rule 37 (vardecl)


state 202

   58 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R
   61 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 206
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 185
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 203

   59 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE block .

    $default  reduce using rule 59 (ifelse)


state 204

   63 for: FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   64    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 207
    COMMA      shift, and go to state 208


state 205

   67 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 209


state 206

   58 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 58 (ifelse)


state 207

   63 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 210


state 208

   64 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    SQUARE_BRACKET_L  shift, and go to state 37
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 40

    expr      go to state 211
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 209

   67 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON .

    $default  reduce using rule 67 (dowhile)


state 210

   63 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   65    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 212
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 213
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 211

   64 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 214


state 212

   63 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 63 (for)


state 213

   65 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 215


state 214

   64 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 216


state 215

   65 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 65 (for)


state 216

   64 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   66    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L         shift, and go to state 32
    MINUS             shift, and go to state 33
    NOT               shift, and go to state 34
    TRUEVAL           shift, and go to state 35
    FALSEVAL          shift, and go to state 36
    CURLY_BRACKET_R   shift, and go to state 217
    RETURN            shift, and go to state 73
    SQUARE_BRACKET_L  shift, and go to state 37
    IF                shift, and go to state 75
    FOR               shift, and go to state 76
    DO                shift, and go to state 77
    WHILE             shift, and go to state 78
    NUM               shift, and go to state 38
    FLOAT             shift, and go to state 39
    ID                shift, and go to state 79

    stmts     go to state 218
    stmt      go to state 84
    return    go to state 85
    ifelse    go to state 86
    assign    go to state 87
    for       go to state 88
    dowhile   go to state 89
    while     go to state 90
    varlet    go to state 91
    expr      go to state 92
    cast      go to state 42
    funcall   go to state 43
    arrexpr   go to state 44
    constant  go to state 45
    floatval  go to state 46
    intval    go to state 47
    boolval   go to state 48
    monop     go to state 49


state 217

   64 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 64 (for)


state 218

   66 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 219


state 219

   66 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 66 (for)
