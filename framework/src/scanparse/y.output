Useless nonterminals

   param


Terminals which are not used

   COMMA
   NE
   INTTYPE
   FLOATTYPE
   BOOLTYPE


Useless rules

   72 param: type ID ids param
   73      | type ID ids
   74      | type ID


State 94 conflicts: 7 shift/reduce
State 100 conflicts: 3 shift/reduce
State 101 conflicts: 6 shift/reduce
State 103 conflicts: 3 shift/reduce
State 111 conflicts: 3 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decls

    2 decls: decl
    3      | decl decls

    4 decl: fundef
    5     | globdef
    6     | globdecl

    7 globdecl: type ID ids SEMICOLON
    8         | type ID SEMICOLON

    9 globdef: type ID LET expr SEMICOLON

   10 fundef: type ID BRACKET_L BRACKET_R funbody

   11 fundefs: fundef fundefs
   12        | fundef

   13 ids: ID ids
   14    | ID

   15 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R
   16        | CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R
   17        | CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R
   18        | CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R
   19        | CURLY_BRACKET_L vardecl CURLY_BRACKET_R
   20        | CURLY_BRACKET_L stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L fundefs CURLY_BRACKET_R
   22        | CURLY_BRACKET_L CURLY_BRACKET_R

   23 vardecl: type ID LET exprs expr SEMICOLON vardecl
   24        | type ID LET exprs expr SEMICOLON
   25        | type ID LET exprs SEMICOLON vardecl
   26        | type ID LET expr SEMICOLON vardecl
   27        | type ID LET exprs SEMICOLON
   28        | type ID LET expr SEMICOLON
   29        | type ID LET SEMICOLON vardecl
   30        | type ID SEMICOLON

   31 stmts: stmt stmts
   32      | stmt

   33 stmt: assign
   34     | return
   35     | ifelse

   36 return: RETURN expr SEMICOLON
   37       | RETURN SEMICOLON

   38 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block
   39       | IF BRACKET_L expr BRACKET_R block
   40       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   41       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

   42 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R

   43 assign: varlet LET expr SEMICOLON

   44 varlet: ID

   45 expr: constant
   46     | ID
   47     | BRACKET_L expr binop expr BRACKET_R

   48 exprs: expr
   49      | expr exprs

   50 constant: floatval
   51         | intval
   52         | boolval

   53 floatval: FLOAT

   54 intval: NUM

   55 boolval: TRUEVAL
   56        | FALSEVAL

   57 binop: PLUS
   58      | MINUS
   59      | STAR
   60      | SLASH
   61      | PERCENT
   62      | LE
   63      | LT
   64      | GE
   65      | GT
   66      | EQ
   67      | OR
   68      | AND

   69 type: INT_TYPE
   70     | FLOAT_TYPE
   71     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 69
FLOAT_TYPE (259) 70
BOOL_TYPE (260) 71
BRACKET_L (261) 10 38 39 40 41 47
BRACKET_R (262) 10 38 39 40 41 47
COMMA (263)
SEMICOLON (264) 7 8 9 23 24 25 26 27 28 29 30 36 37 43
MINUS (265) 58
PLUS (266) 57
STAR (267) 59
SLASH (268) 60
PERCENT (269) 61
LE (270) 62
LT (271) 63
GE (272) 64
GT (273) 65
EQ (274) 66
NE (275)
OR (276) 67
AND (277) 68
TRUEVAL (278) 55
FALSEVAL (279) 56
LET (280) 9 23 24 25 26 27 28 29 43
INTTYPE (281)
FLOATTYPE (282)
BOOLTYPE (283)
CURLY_BRACKET_L (284) 15 16 17 18 19 20 21 22 40 41 42
CURLY_BRACKET_R (285) 15 16 17 18 19 20 21 22 40 41 42
RETURN (286) 36 37
IF (287) 38 39 40 41
ELSE (288) 38 40
NUM (289) 54
FLOAT (290) 53
ID (291) 7 8 9 10 13 14 23 24 25 26 27 28 29 30 44 46


Nonterminals, with rules where they appear

$accept (37)
    on left: 0
program (38)
    on left: 1, on right: 0
decls (39)
    on left: 2 3, on right: 1 3
decl (40)
    on left: 4 5 6, on right: 2 3
globdecl (41)
    on left: 7 8, on right: 6
globdef (42)
    on left: 9, on right: 5
fundef (43)
    on left: 10, on right: 4 11 12
fundefs (44)
    on left: 11 12, on right: 11 15 16 18 21
ids (45)
    on left: 13 14, on right: 7 13
funbody (46)
    on left: 15 16 17 18 19 20 21 22, on right: 10
vardecl (47)
    on left: 23 24 25 26 27 28 29 30, on right: 15 17 18 19 23 25 26
    29
stmts (48)
    on left: 31 32, on right: 15 16 17 20 31 42
stmt (49)
    on left: 33 34 35, on right: 31 32
return (50)
    on left: 36 37, on right: 34
ifelse (51)
    on left: 38 39 40 41, on right: 35
block (52)
    on left: 42, on right: 38 39
assign (53)
    on left: 43, on right: 33
varlet (54)
    on left: 44, on right: 43
expr (55)
    on left: 45 46 47, on right: 9 23 24 26 28 36 38 39 40 41 43 47
    48 49
exprs (56)
    on left: 48 49, on right: 23 24 25 27 49
constant (57)
    on left: 50 51 52, on right: 45
floatval (58)
    on left: 53, on right: 50
intval (59)
    on left: 54, on right: 51
boolval (60)
    on left: 55 56, on right: 52
binop (61)
    on left: 57 58 59 60 61 62 63 64 65 66 67 68, on right: 47
type (62)
    on left: 69 70 71, on right: 7 8 9 10 23 24 25 26 27 28 29 30


state 0

    0 $accept: . program $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    program   go to state 4
    decls     go to state 5
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 1

   69 type: INT_TYPE .

    $default  reduce using rule 69 (type)


state 2

   70 type: FLOAT_TYPE .

    $default  reduce using rule 70 (type)


state 3

   71 type: BOOL_TYPE .

    $default  reduce using rule 71 (type)


state 4

    0 $accept: program . $end

    $end  shift, and go to state 11


state 5

    1 program: decls .

    $default  reduce using rule 1 (program)


state 6

    2 decls: decl .
    3      | decl . decls

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 2 (decls)

    decls     go to state 12
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 7

    6 decl: globdecl .

    $default  reduce using rule 6 (decl)


state 8

    5 decl: globdef .

    $default  reduce using rule 5 (decl)


state 9

    4 decl: fundef .

    $default  reduce using rule 4 (decl)


state 10

    7 globdecl: type . ID ids SEMICOLON
    8         | type . ID SEMICOLON
    9 globdef: type . ID LET expr SEMICOLON
   10 fundef: type . ID BRACKET_L BRACKET_R funbody

    ID  shift, and go to state 13


state 11

    0 $accept: program $end .

    $default  accept


state 12

    3 decls: decl decls .

    $default  reduce using rule 3 (decls)


state 13

    7 globdecl: type ID . ids SEMICOLON
    8         | type ID . SEMICOLON
    9 globdef: type ID . LET expr SEMICOLON
   10 fundef: type ID . BRACKET_L BRACKET_R funbody

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 15
    LET        shift, and go to state 16
    ID         shift, and go to state 17

    ids  go to state 18


state 14

   10 fundef: type ID BRACKET_L . BRACKET_R funbody

    BRACKET_R  shift, and go to state 19


state 15

    8 globdecl: type ID SEMICOLON .

    $default  reduce using rule 8 (globdecl)


state 16

    9 globdef: type ID LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 20
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 26
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 17

   13 ids: ID . ids
   14    | ID .

    ID  shift, and go to state 17

    $default  reduce using rule 14 (ids)

    ids  go to state 31


state 18

    7 globdecl: type ID ids . SEMICOLON

    SEMICOLON  shift, and go to state 32


state 19

   10 fundef: type ID BRACKET_L BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 33

    funbody  go to state 34


state 20

   47 expr: BRACKET_L . expr binop expr BRACKET_R

    BRACKET_L  shift, and go to state 20
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 35
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 21

   55 boolval: TRUEVAL .

    $default  reduce using rule 55 (boolval)


state 22

   56 boolval: FALSEVAL .

    $default  reduce using rule 56 (boolval)


state 23

   54 intval: NUM .

    $default  reduce using rule 54 (intval)


state 24

   53 floatval: FLOAT .

    $default  reduce using rule 53 (floatval)


state 25

   46 expr: ID .

    $default  reduce using rule 46 (expr)


state 26

    9 globdef: type ID LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 36


state 27

   45 expr: constant .

    $default  reduce using rule 45 (expr)


state 28

   50 constant: floatval .

    $default  reduce using rule 50 (constant)


state 29

   51 constant: intval .

    $default  reduce using rule 51 (constant)


state 30

   52 constant: boolval .

    $default  reduce using rule 52 (constant)


state 31

   13 ids: ID ids .

    $default  reduce using rule 13 (ids)


state 32

    7 globdecl: type ID ids SEMICOLON .

    $default  reduce using rule 7 (globdecl)


state 33

   15 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   16        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   17        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   18        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   19        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   20        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   22        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    CURLY_BRACKET_R  shift, and go to state 37
    RETURN           shift, and go to state 38
    IF               shift, and go to state 39
    ID               shift, and go to state 40

    fundef   go to state 41
    fundefs  go to state 42
    vardecl  go to state 43
    stmts    go to state 44
    stmt     go to state 45
    return   go to state 46
    ifelse   go to state 47
    assign   go to state 48
    varlet   go to state 49
    type     go to state 50


state 34

   10 fundef: type ID BRACKET_L BRACKET_R funbody .

    $default  reduce using rule 10 (fundef)


state 35

   47 expr: BRACKET_L expr . binop expr BRACKET_R

    MINUS    shift, and go to state 51
    PLUS     shift, and go to state 52
    STAR     shift, and go to state 53
    SLASH    shift, and go to state 54
    PERCENT  shift, and go to state 55
    LE       shift, and go to state 56
    LT       shift, and go to state 57
    GE       shift, and go to state 58
    GT       shift, and go to state 59
    EQ       shift, and go to state 60
    OR       shift, and go to state 61
    AND      shift, and go to state 62

    binop  go to state 63


state 36

    9 globdef: type ID LET expr SEMICOLON .

    $default  reduce using rule 9 (globdef)


state 37

   22 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 22 (funbody)


state 38

   36 return: RETURN . expr SEMICOLON
   37       | RETURN . SEMICOLON

    BRACKET_L  shift, and go to state 20
    SEMICOLON  shift, and go to state 64
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 65
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 39

   38 ifelse: IF . BRACKET_L expr BRACKET_R block ELSE block
   39       | IF . BRACKET_L expr BRACKET_R block
   40       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   41       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 66


state 40

   44 varlet: ID .

    $default  reduce using rule 44 (varlet)


state 41

   11 fundefs: fundef . fundefs
   12        | fundef .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 12 (fundefs)

    fundef   go to state 41
    fundefs  go to state 67
    type     go to state 68


state 42

   16 funbody: CURLY_BRACKET_L fundefs . stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L fundefs . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 69
    RETURN           shift, and go to state 38
    IF               shift, and go to state 39
    ID               shift, and go to state 40

    stmts   go to state 70
    stmt    go to state 45
    return  go to state 46
    ifelse  go to state 47
    assign  go to state 48
    varlet  go to state 49


state 43

   15 funbody: CURLY_BRACKET_L vardecl . fundefs stmts CURLY_BRACKET_R
   17        | CURLY_BRACKET_L vardecl . stmts CURLY_BRACKET_R
   18        | CURLY_BRACKET_L vardecl . fundefs CURLY_BRACKET_R
   19        | CURLY_BRACKET_L vardecl . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    CURLY_BRACKET_R  shift, and go to state 71
    RETURN           shift, and go to state 38
    IF               shift, and go to state 39
    ID               shift, and go to state 40

    fundef   go to state 41
    fundefs  go to state 72
    stmts    go to state 73
    stmt     go to state 45
    return   go to state 46
    ifelse   go to state 47
    assign   go to state 48
    varlet   go to state 49
    type     go to state 68


state 44

   20 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 74


state 45

   31 stmts: stmt . stmts
   32      | stmt .

    RETURN  shift, and go to state 38
    IF      shift, and go to state 39
    ID      shift, and go to state 40

    $default  reduce using rule 32 (stmts)

    stmts   go to state 75
    stmt    go to state 45
    return  go to state 46
    ifelse  go to state 47
    assign  go to state 48
    varlet  go to state 49


state 46

   34 stmt: return .

    $default  reduce using rule 34 (stmt)


state 47

   35 stmt: ifelse .

    $default  reduce using rule 35 (stmt)


state 48

   33 stmt: assign .

    $default  reduce using rule 33 (stmt)


state 49

   43 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 76


state 50

   10 fundef: type . ID BRACKET_L BRACKET_R funbody
   23 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   24        | type . ID LET exprs expr SEMICOLON
   25        | type . ID LET exprs SEMICOLON vardecl
   26        | type . ID LET expr SEMICOLON vardecl
   27        | type . ID LET exprs SEMICOLON
   28        | type . ID LET expr SEMICOLON
   29        | type . ID LET SEMICOLON vardecl
   30        | type . ID SEMICOLON

    ID  shift, and go to state 77


state 51

   58 binop: MINUS .

    $default  reduce using rule 58 (binop)


state 52

   57 binop: PLUS .

    $default  reduce using rule 57 (binop)


state 53

   59 binop: STAR .

    $default  reduce using rule 59 (binop)


state 54

   60 binop: SLASH .

    $default  reduce using rule 60 (binop)


state 55

   61 binop: PERCENT .

    $default  reduce using rule 61 (binop)


state 56

   62 binop: LE .

    $default  reduce using rule 62 (binop)


state 57

   63 binop: LT .

    $default  reduce using rule 63 (binop)


state 58

   64 binop: GE .

    $default  reduce using rule 64 (binop)


state 59

   65 binop: GT .

    $default  reduce using rule 65 (binop)


state 60

   66 binop: EQ .

    $default  reduce using rule 66 (binop)


state 61

   67 binop: OR .

    $default  reduce using rule 67 (binop)


state 62

   68 binop: AND .

    $default  reduce using rule 68 (binop)


state 63

   47 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L  shift, and go to state 20
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 78
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 64

   37 return: RETURN SEMICOLON .

    $default  reduce using rule 37 (return)


state 65

   36 return: RETURN expr . SEMICOLON

    SEMICOLON  shift, and go to state 79


state 66

   38 ifelse: IF BRACKET_L . expr BRACKET_R block ELSE block
   39       | IF BRACKET_L . expr BRACKET_R block
   40       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   41       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 20
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 80
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 67

   11 fundefs: fundef fundefs .

    $default  reduce using rule 11 (fundefs)


state 68

   10 fundef: type . ID BRACKET_L BRACKET_R funbody

    ID  shift, and go to state 81


state 69

   21 funbody: CURLY_BRACKET_L fundefs CURLY_BRACKET_R .

    $default  reduce using rule 21 (funbody)


state 70

   16 funbody: CURLY_BRACKET_L fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 82


state 71

   19 funbody: CURLY_BRACKET_L vardecl CURLY_BRACKET_R .

    $default  reduce using rule 19 (funbody)


state 72

   15 funbody: CURLY_BRACKET_L vardecl fundefs . stmts CURLY_BRACKET_R
   18        | CURLY_BRACKET_L vardecl fundefs . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 83
    RETURN           shift, and go to state 38
    IF               shift, and go to state 39
    ID               shift, and go to state 40

    stmts   go to state 84
    stmt    go to state 45
    return  go to state 46
    ifelse  go to state 47
    assign  go to state 48
    varlet  go to state 49


state 73

   17 funbody: CURLY_BRACKET_L vardecl stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 85


state 74

   20 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 20 (funbody)


state 75

   31 stmts: stmt stmts .

    $default  reduce using rule 31 (stmts)


state 76

   43 assign: varlet LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 20
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 86
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 77

   10 fundef: type ID . BRACKET_L BRACKET_R funbody
   23 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   24        | type ID . LET exprs expr SEMICOLON
   25        | type ID . LET exprs SEMICOLON vardecl
   26        | type ID . LET expr SEMICOLON vardecl
   27        | type ID . LET exprs SEMICOLON
   28        | type ID . LET expr SEMICOLON
   29        | type ID . LET SEMICOLON vardecl
   30        | type ID . SEMICOLON

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 87
    LET        shift, and go to state 88


state 78

   47 expr: BRACKET_L expr binop expr . BRACKET_R

    BRACKET_R  shift, and go to state 89


state 79

   36 return: RETURN expr SEMICOLON .

    $default  reduce using rule 36 (return)


state 80

   38 ifelse: IF BRACKET_L expr . BRACKET_R block ELSE block
   39       | IF BRACKET_L expr . BRACKET_R block
   40       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   41       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 90


state 81

   10 fundef: type ID . BRACKET_L BRACKET_R funbody

    BRACKET_L  shift, and go to state 14


state 82

   16 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 16 (funbody)


state 83

   18 funbody: CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R .

    $default  reduce using rule 18 (funbody)


state 84

   15 funbody: CURLY_BRACKET_L vardecl fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 91


state 85

   17 funbody: CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R .

    $default  reduce using rule 17 (funbody)


state 86

   43 assign: varlet LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 92


state 87

   30 vardecl: type ID SEMICOLON .

    $default  reduce using rule 30 (vardecl)


state 88

   23 vardecl: type ID LET . exprs expr SEMICOLON vardecl
   24        | type ID LET . exprs expr SEMICOLON
   25        | type ID LET . exprs SEMICOLON vardecl
   26        | type ID LET . expr SEMICOLON vardecl
   27        | type ID LET . exprs SEMICOLON
   28        | type ID LET . expr SEMICOLON
   29        | type ID LET . SEMICOLON vardecl

    BRACKET_L  shift, and go to state 20
    SEMICOLON  shift, and go to state 93
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 94
    exprs     go to state 95
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 89

   47 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 47 (expr)


state 90

   38 ifelse: IF BRACKET_L expr BRACKET_R . block ELSE block
   39       | IF BRACKET_L expr BRACKET_R . block
   40       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   41       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 96

    block  go to state 97


state 91

   15 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 15 (funbody)


state 92

   43 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 43 (assign)


state 93

   29 vardecl: type ID LET SEMICOLON . vardecl

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    vardecl  go to state 98
    type     go to state 99


state 94

   26 vardecl: type ID LET expr . SEMICOLON vardecl
   28        | type ID LET expr . SEMICOLON
   48 exprs: expr .
   49      | expr . exprs

    BRACKET_L  shift, and go to state 20
    SEMICOLON  shift, and go to state 100
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    BRACKET_L  [reduce using rule 48 (exprs)]
    SEMICOLON  [reduce using rule 48 (exprs)]
    TRUEVAL    [reduce using rule 48 (exprs)]
    FALSEVAL   [reduce using rule 48 (exprs)]
    NUM        [reduce using rule 48 (exprs)]
    FLOAT      [reduce using rule 48 (exprs)]
    ID         [reduce using rule 48 (exprs)]

    expr      go to state 101
    exprs     go to state 102
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 95

   23 vardecl: type ID LET exprs . expr SEMICOLON vardecl
   24        | type ID LET exprs . expr SEMICOLON
   25        | type ID LET exprs . SEMICOLON vardecl
   27        | type ID LET exprs . SEMICOLON

    BRACKET_L  shift, and go to state 20
    SEMICOLON  shift, and go to state 103
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    expr      go to state 104
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 96

   40 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   41       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   42 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 105
    RETURN           shift, and go to state 38
    IF               shift, and go to state 39
    ID               shift, and go to state 40

    stmts   go to state 106
    stmt    go to state 45
    return  go to state 46
    ifelse  go to state 47
    assign  go to state 48
    varlet  go to state 49


state 97

   38 ifelse: IF BRACKET_L expr BRACKET_R block . ELSE block
   39       | IF BRACKET_L expr BRACKET_R block .

    ELSE  shift, and go to state 107

    $default  reduce using rule 39 (ifelse)


state 98

   29 vardecl: type ID LET SEMICOLON vardecl .

    $default  reduce using rule 29 (vardecl)


state 99

   23 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   24        | type . ID LET exprs expr SEMICOLON
   25        | type . ID LET exprs SEMICOLON vardecl
   26        | type . ID LET expr SEMICOLON vardecl
   27        | type . ID LET exprs SEMICOLON
   28        | type . ID LET expr SEMICOLON
   29        | type . ID LET SEMICOLON vardecl
   30        | type . ID SEMICOLON

    ID  shift, and go to state 108


state 100

   26 vardecl: type ID LET expr SEMICOLON . vardecl
   28        | type ID LET expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 28 (vardecl)]
    FLOAT_TYPE  [reduce using rule 28 (vardecl)]
    BOOL_TYPE   [reduce using rule 28 (vardecl)]
    $default    reduce using rule 28 (vardecl)

    vardecl  go to state 109
    type     go to state 99


state 101

   48 exprs: expr .
   49      | expr . exprs

    BRACKET_L  shift, and go to state 20
    TRUEVAL    shift, and go to state 21
    FALSEVAL   shift, and go to state 22
    NUM        shift, and go to state 23
    FLOAT      shift, and go to state 24
    ID         shift, and go to state 25

    BRACKET_L  [reduce using rule 48 (exprs)]
    TRUEVAL    [reduce using rule 48 (exprs)]
    FALSEVAL   [reduce using rule 48 (exprs)]
    NUM        [reduce using rule 48 (exprs)]
    FLOAT      [reduce using rule 48 (exprs)]
    ID         [reduce using rule 48 (exprs)]
    $default   reduce using rule 48 (exprs)

    expr      go to state 101
    exprs     go to state 102
    constant  go to state 27
    floatval  go to state 28
    intval    go to state 29
    boolval   go to state 30


state 102

   49 exprs: expr exprs .

    $default  reduce using rule 49 (exprs)


state 103

   25 vardecl: type ID LET exprs SEMICOLON . vardecl
   27        | type ID LET exprs SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 27 (vardecl)]
    FLOAT_TYPE  [reduce using rule 27 (vardecl)]
    BOOL_TYPE   [reduce using rule 27 (vardecl)]
    $default    reduce using rule 27 (vardecl)

    vardecl  go to state 110
    type     go to state 99


state 104

   23 vardecl: type ID LET exprs expr . SEMICOLON vardecl
   24        | type ID LET exprs expr . SEMICOLON

    SEMICOLON  shift, and go to state 111


state 105

   40 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   41       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    ELSE  shift, and go to state 112

    $default  reduce using rule 41 (ifelse)


state 106

   42 block: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 113


state 107

   38 ifelse: IF BRACKET_L expr BRACKET_R block ELSE . block

    CURLY_BRACKET_L  shift, and go to state 114

    block  go to state 115


state 108

   23 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   24        | type ID . LET exprs expr SEMICOLON
   25        | type ID . LET exprs SEMICOLON vardecl
   26        | type ID . LET expr SEMICOLON vardecl
   27        | type ID . LET exprs SEMICOLON
   28        | type ID . LET expr SEMICOLON
   29        | type ID . LET SEMICOLON vardecl
   30        | type ID . SEMICOLON

    SEMICOLON  shift, and go to state 87
    LET        shift, and go to state 88


state 109

   26 vardecl: type ID LET expr SEMICOLON vardecl .

    $default  reduce using rule 26 (vardecl)


state 110

   25 vardecl: type ID LET exprs SEMICOLON vardecl .

    $default  reduce using rule 25 (vardecl)


state 111

   23 vardecl: type ID LET exprs expr SEMICOLON . vardecl
   24        | type ID LET exprs expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 24 (vardecl)]
    FLOAT_TYPE  [reduce using rule 24 (vardecl)]
    BOOL_TYPE   [reduce using rule 24 (vardecl)]
    $default    reduce using rule 24 (vardecl)

    vardecl  go to state 116
    type     go to state 99


state 112

   40 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 117


state 113

   42 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 42 (block)


state 114

   42 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 38
    IF      shift, and go to state 39
    ID      shift, and go to state 40

    stmts   go to state 106
    stmt    go to state 45
    return  go to state 46
    ifelse  go to state 47
    assign  go to state 48
    varlet  go to state 49


state 115

   38 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block .

    $default  reduce using rule 38 (ifelse)


state 116

   23 vardecl: type ID LET exprs expr SEMICOLON vardecl .

    $default  reduce using rule 23 (vardecl)


state 117

   40 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 118


state 118

   40 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 40 (ifelse)
