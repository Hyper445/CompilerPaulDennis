Terminals which are not used

   NE
   NEG
   INTTYPE
   FLOATTYPE
   BOOLTYPE


State 120 conflicts: 9 shift/reduce
State 129 conflicts: 3 shift/reduce
State 130 conflicts: 8 shift/reduce
State 132 conflicts: 3 shift/reduce
State 143 conflicts: 3 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decls

    2 decls: decl
    3      | decl decls

    4 decl: fundef
    5     | globdef
    6     | globdecl

    7 globdecl: type ID ids SEMICOLON
    8         | type ID SEMICOLON

    9 globdef: type ID LET expr SEMICOLON

   10 fundef: type ID BRACKET_L param BRACKET_R funbody

   11 param: type ID ids param
   12      | type ID ids
   13      | type ID COMMA param
   14      | type ID

   15 fundefs: fundef fundefs
   16        | fundef

   17 ids: ID ids
   18    | ID

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L CURLY_BRACKET_R

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl
   28        | type ID LET exprs expr SEMICOLON
   29        | type ID LET exprs SEMICOLON vardecl
   30        | type ID LET expr SEMICOLON vardecl
   31        | type ID LET exprs SEMICOLON
   32        | type ID LET expr SEMICOLON
   33        | type ID LET SEMICOLON vardecl
   34        | type ID SEMICOLON

   35 stmts: stmt stmts
   36      | stmt

   37 stmt: assign
   38     | return
   39     | ifelse
   40     | for
   41     | doWhile
   42     | while

   43 return: RETURN expr SEMICOLON
   44       | RETURN SEMICOLON

   45 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block
   46       | IF BRACKET_L expr BRACKET_R block
   47       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

   49 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R

   50 assign: varlet LET expr SEMICOLON

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   57 varlet: ID

   58 expr: constant
   59     | ID
   60     | monop expr
   61     | BRACKET_L expr binop expr BRACKET_R

   62 exprs: expr
   63      | expr exprs

   64 constant: floatval
   65         | intval
   66         | boolval

   67 floatval: FLOAT

   68 intval: NUM

   69 boolval: TRUEVAL
   70        | FALSEVAL

   71 binop: PLUS
   72      | MINUS
   73      | STAR
   74      | SLASH
   75      | PERCENT
   76      | LE
   77      | LT
   78      | GE
   79      | GT
   80      | EQ
   81      | OR
   82      | AND

   83 monop: NOT
   84      | MINUS

   85 type: INT_TYPE
   86     | FLOAT_TYPE
   87     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 85
FLOAT_TYPE (259) 86
BOOL_TYPE (260) 87
BRACKET_L (261) 10 45 46 47 48 51 52 53 54 55 56 61
BRACKET_R (262) 10 45 46 47 48 51 52 53 54 55 56 61
COMMA (263) 13 51 52 53 54
SEMICOLON (264) 7 8 9 27 28 29 30 31 32 33 34 43 44 50 55
MINUS (265) 72 84
PLUS (266) 71
STAR (267) 73
SLASH (268) 74
PERCENT (269) 75
LE (270) 76
LT (271) 77
GE (272) 78
GT (273) 79
EQ (274) 80
NE (275)
OR (276) 81
AND (277) 82
NOT (278) 83
NEG (279)
TRUEVAL (280) 69
FALSEVAL (281) 70
LET (282) 9 27 28 29 30 31 32 33 50 51 52 53 54
INTTYPE (283)
FLOATTYPE (284)
BOOLTYPE (285)
CURLY_BRACKET_L (286) 19 20 21 22 23 24 25 26 47 48 49 51 52 53 54
    55 56
CURLY_BRACKET_R (287) 19 20 21 22 23 24 25 26 47 48 49 51 52 53 54
    55 56
RETURN (288) 43 44
IF (289) 45 46 47 48
ELSE (290) 45 47
FOR (291) 51 52 53 54
DO (292) 55
WHILE (293) 55 56
NUM (294) 68
FLOAT (295) 67
ID (296) 7 8 9 10 11 12 13 14 17 18 27 28 29 30 31 32 33 34 51 52 53
    54 57 59


Nonterminals, with rules where they appear

$accept (42)
    on left: 0
program (43)
    on left: 1, on right: 0
decls (44)
    on left: 2 3, on right: 1 3
decl (45)
    on left: 4 5 6, on right: 2 3
globdecl (46)
    on left: 7 8, on right: 6
globdef (47)
    on left: 9, on right: 5
fundef (48)
    on left: 10, on right: 4 15 16
param (49)
    on left: 11 12 13 14, on right: 10 11 13
fundefs (50)
    on left: 15 16, on right: 15 19 20 22 25
ids (51)
    on left: 17 18, on right: 7 11 12 17
funbody (52)
    on left: 19 20 21 22 23 24 25 26, on right: 10
vardecl (53)
    on left: 27 28 29 30 31 32 33 34, on right: 19 21 22 23 27 29 30
    33
stmts (54)
    on left: 35 36, on right: 19 20 21 24 35 49 53 54 55 56
stmt (55)
    on left: 37 38 39 40 41 42, on right: 35 36
return (56)
    on left: 43 44, on right: 38
ifelse (57)
    on left: 45 46 47 48, on right: 39
block (58)
    on left: 49, on right: 45 46
assign (59)
    on left: 50, on right: 37
for (60)
    on left: 51 52 53 54, on right: 40
doWhile (61)
    on left: 55, on right: 41
while (62)
    on left: 56, on right: 42
varlet (63)
    on left: 57, on right: 50
expr (64)
    on left: 58 59 60 61, on right: 9 27 28 30 32 43 45 46 47 48 50
    51 52 53 54 55 56 60 61 62 63
exprs (65)
    on left: 62 63, on right: 27 28 29 31 63
constant (66)
    on left: 64 65 66, on right: 58
floatval (67)
    on left: 67, on right: 64
intval (68)
    on left: 68, on right: 65
boolval (69)
    on left: 69 70, on right: 66
binop (70)
    on left: 71 72 73 74 75 76 77 78 79 80 81 82, on right: 61
monop (71)
    on left: 83 84, on right: 60
type (72)
    on left: 85 86 87, on right: 7 8 9 10 11 12 13 14 27 28 29 30 31
    32 33 34 51 52 53 54


state 0

    0 $accept: . program $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    program   go to state 4
    decls     go to state 5
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 1

   85 type: INT_TYPE .

    $default  reduce using rule 85 (type)


state 2

   86 type: FLOAT_TYPE .

    $default  reduce using rule 86 (type)


state 3

   87 type: BOOL_TYPE .

    $default  reduce using rule 87 (type)


state 4

    0 $accept: program . $end

    $end  shift, and go to state 11


state 5

    1 program: decls .

    $default  reduce using rule 1 (program)


state 6

    2 decls: decl .
    3      | decl . decls

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 2 (decls)

    decls     go to state 12
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 7

    6 decl: globdecl .

    $default  reduce using rule 6 (decl)


state 8

    5 decl: globdef .

    $default  reduce using rule 5 (decl)


state 9

    4 decl: fundef .

    $default  reduce using rule 4 (decl)


state 10

    7 globdecl: type . ID ids SEMICOLON
    8         | type . ID SEMICOLON
    9 globdef: type . ID LET expr SEMICOLON
   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 13


state 11

    0 $accept: program $end .

    $default  accept


state 12

    3 decls: decl decls .

    $default  reduce using rule 3 (decls)


state 13

    7 globdecl: type ID . ids SEMICOLON
    8         | type ID . SEMICOLON
    9 globdef: type ID . LET expr SEMICOLON
   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 15
    LET        shift, and go to state 16
    ID         shift, and go to state 17

    ids  go to state 18


state 14

   10 fundef: type ID BRACKET_L . param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 19
    type   go to state 20


state 15

    8 globdecl: type ID SEMICOLON .

    $default  reduce using rule 8 (globdecl)


state 16

    9 globdef: type ID LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 29
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 17

   17 ids: ID . ids
   18    | ID .

    ID  shift, and go to state 17

    $default  reduce using rule 18 (ids)

    ids  go to state 35


state 18

    7 globdecl: type ID ids . SEMICOLON

    SEMICOLON  shift, and go to state 36


state 19

   10 fundef: type ID BRACKET_L param . BRACKET_R funbody

    BRACKET_R  shift, and go to state 37


state 20

   11 param: type . ID ids param
   12      | type . ID ids
   13      | type . ID COMMA param
   14      | type . ID

    ID  shift, and go to state 38


state 21

   61 expr: BRACKET_L . expr binop expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 39
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 22

   84 monop: MINUS .

    $default  reduce using rule 84 (monop)


state 23

   83 monop: NOT .

    $default  reduce using rule 83 (monop)


state 24

   69 boolval: TRUEVAL .

    $default  reduce using rule 69 (boolval)


state 25

   70 boolval: FALSEVAL .

    $default  reduce using rule 70 (boolval)


state 26

   68 intval: NUM .

    $default  reduce using rule 68 (intval)


state 27

   67 floatval: FLOAT .

    $default  reduce using rule 67 (floatval)


state 28

   59 expr: ID .

    $default  reduce using rule 59 (expr)


state 29

    9 globdef: type ID LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 40


state 30

   58 expr: constant .

    $default  reduce using rule 58 (expr)


state 31

   64 constant: floatval .

    $default  reduce using rule 64 (constant)


state 32

   65 constant: intval .

    $default  reduce using rule 65 (constant)


state 33

   66 constant: boolval .

    $default  reduce using rule 66 (constant)


state 34

   60 expr: monop . expr

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 41
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 35

   17 ids: ID ids .

    $default  reduce using rule 17 (ids)


state 36

    7 globdecl: type ID ids SEMICOLON .

    $default  reduce using rule 7 (globdecl)


state 37

   10 fundef: type ID BRACKET_L param BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 42

    funbody  go to state 43


state 38

   11 param: type ID . ids param
   12      | type ID . ids
   13      | type ID . COMMA param
   14      | type ID .

    COMMA  shift, and go to state 44
    ID     shift, and go to state 17

    $default  reduce using rule 14 (param)

    ids  go to state 45


state 39

   61 expr: BRACKET_L expr . binop expr BRACKET_R

    MINUS    shift, and go to state 46
    PLUS     shift, and go to state 47
    STAR     shift, and go to state 48
    SLASH    shift, and go to state 49
    PERCENT  shift, and go to state 50
    LE       shift, and go to state 51
    LT       shift, and go to state 52
    GE       shift, and go to state 53
    GT       shift, and go to state 54
    EQ       shift, and go to state 55
    OR       shift, and go to state 56
    AND      shift, and go to state 57

    binop  go to state 58


state 40

    9 globdef: type ID LET expr SEMICOLON .

    $default  reduce using rule 9 (globdef)


state 41

   60 expr: monop expr .

    $default  reduce using rule 60 (expr)


state 42

   19 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    CURLY_BRACKET_R  shift, and go to state 59
    RETURN           shift, and go to state 60
    IF               shift, and go to state 61
    FOR              shift, and go to state 62
    DO               shift, and go to state 63
    WHILE            shift, and go to state 64
    ID               shift, and go to state 65

    fundef   go to state 66
    fundefs  go to state 67
    vardecl  go to state 68
    stmts    go to state 69
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77
    type     go to state 78


state 43

   10 fundef: type ID BRACKET_L param BRACKET_R funbody .

    $default  reduce using rule 10 (fundef)


state 44

   13 param: type ID COMMA . param

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 79
    type   go to state 20


state 45

   11 param: type ID ids . param
   12      | type ID ids .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 12 (param)

    param  go to state 80
    type   go to state 20


state 46

   72 binop: MINUS .

    $default  reduce using rule 72 (binop)


state 47

   71 binop: PLUS .

    $default  reduce using rule 71 (binop)


state 48

   73 binop: STAR .

    $default  reduce using rule 73 (binop)


state 49

   74 binop: SLASH .

    $default  reduce using rule 74 (binop)


state 50

   75 binop: PERCENT .

    $default  reduce using rule 75 (binop)


state 51

   76 binop: LE .

    $default  reduce using rule 76 (binop)


state 52

   77 binop: LT .

    $default  reduce using rule 77 (binop)


state 53

   78 binop: GE .

    $default  reduce using rule 78 (binop)


state 54

   79 binop: GT .

    $default  reduce using rule 79 (binop)


state 55

   80 binop: EQ .

    $default  reduce using rule 80 (binop)


state 56

   81 binop: OR .

    $default  reduce using rule 81 (binop)


state 57

   82 binop: AND .

    $default  reduce using rule 82 (binop)


state 58

   61 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 81
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 59

   26 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 26 (funbody)


state 60

   43 return: RETURN . expr SEMICOLON
   44       | RETURN . SEMICOLON

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 82
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 83
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 61

   45 ifelse: IF . BRACKET_L expr BRACKET_R block ELSE block
   46       | IF . BRACKET_L expr BRACKET_R block
   47       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 84


state 62

   51 for: FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 85


state 63

   55 doWhile: DO . CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_L  shift, and go to state 86


state 64

   56 while: WHILE . BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 87


state 65

   57 varlet: ID .

    $default  reduce using rule 57 (varlet)


state 66

   15 fundefs: fundef . fundefs
   16        | fundef .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 16 (fundefs)

    fundef   go to state 66
    fundefs  go to state 88
    type     go to state 89


state 67

   20 funbody: CURLY_BRACKET_L fundefs . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 90
    RETURN           shift, and go to state 60
    IF               shift, and go to state 61
    FOR              shift, and go to state 62
    DO               shift, and go to state 63
    WHILE            shift, and go to state 64
    ID               shift, and go to state 65

    stmts    go to state 91
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 68

   19 funbody: CURLY_BRACKET_L vardecl . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl . fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    CURLY_BRACKET_R  shift, and go to state 92
    RETURN           shift, and go to state 60
    IF               shift, and go to state 61
    FOR              shift, and go to state 62
    DO               shift, and go to state 63
    WHILE            shift, and go to state 64
    ID               shift, and go to state 65

    fundef   go to state 66
    fundefs  go to state 93
    stmts    go to state 94
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77
    type     go to state 89


state 69

   24 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 95


state 70

   35 stmts: stmt . stmts
   36      | stmt .

    RETURN  shift, and go to state 60
    IF      shift, and go to state 61
    FOR     shift, and go to state 62
    DO      shift, and go to state 63
    WHILE   shift, and go to state 64
    ID      shift, and go to state 65

    $default  reduce using rule 36 (stmts)

    stmts    go to state 96
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 71

   38 stmt: return .

    $default  reduce using rule 38 (stmt)


state 72

   39 stmt: ifelse .

    $default  reduce using rule 39 (stmt)


state 73

   37 stmt: assign .

    $default  reduce using rule 37 (stmt)


state 74

   40 stmt: for .

    $default  reduce using rule 40 (stmt)


state 75

   41 stmt: doWhile .

    $default  reduce using rule 41 (stmt)


state 76

   42 stmt: while .

    $default  reduce using rule 42 (stmt)


state 77

   50 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 97


state 78

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody
   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 98


state 79

   13 param: type ID COMMA param .

    $default  reduce using rule 13 (param)


state 80

   11 param: type ID ids param .

    $default  reduce using rule 11 (param)


state 81

   61 expr: BRACKET_L expr binop expr . BRACKET_R

    BRACKET_R  shift, and go to state 99


state 82

   44 return: RETURN SEMICOLON .

    $default  reduce using rule 44 (return)


state 83

   43 return: RETURN expr . SEMICOLON

    SEMICOLON  shift, and go to state 100


state 84

   45 ifelse: IF BRACKET_L . expr BRACKET_R block ELSE block
   46       | IF BRACKET_L . expr BRACKET_R block
   47       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 101
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 85

   51 for: FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 102


state 86

   55 doWhile: DO CURLY_BRACKET_L . stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    RETURN  shift, and go to state 60
    IF      shift, and go to state 61
    FOR     shift, and go to state 62
    DO      shift, and go to state 63
    WHILE   shift, and go to state 64
    ID      shift, and go to state 65

    stmts    go to state 103
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 87

   56 while: WHILE BRACKET_L . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 104
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 88

   15 fundefs: fundef fundefs .

    $default  reduce using rule 15 (fundefs)


state 89

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 105


state 90

   25 funbody: CURLY_BRACKET_L fundefs CURLY_BRACKET_R .

    $default  reduce using rule 25 (funbody)


state 91

   20 funbody: CURLY_BRACKET_L fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 106


state 92

   23 funbody: CURLY_BRACKET_L vardecl CURLY_BRACKET_R .

    $default  reduce using rule 23 (funbody)


state 93

   19 funbody: CURLY_BRACKET_L vardecl fundefs . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 107
    RETURN           shift, and go to state 60
    IF               shift, and go to state 61
    FOR              shift, and go to state 62
    DO               shift, and go to state 63
    WHILE            shift, and go to state 64
    ID               shift, and go to state 65

    stmts    go to state 108
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 94

   21 funbody: CURLY_BRACKET_L vardecl stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 109


state 95

   24 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 24 (funbody)


state 96

   35 stmts: stmt stmts .

    $default  reduce using rule 35 (stmts)


state 97

   50 assign: varlet LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 110
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 98

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody
   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 111
    LET        shift, and go to state 112


state 99

   61 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 61 (expr)


state 100

   43 return: RETURN expr SEMICOLON .

    $default  reduce using rule 43 (return)


state 101

   45 ifelse: IF BRACKET_L expr . BRACKET_R block ELSE block
   46       | IF BRACKET_L expr . BRACKET_R block
   47       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 113


state 102

   51 for: FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    ID  shift, and go to state 114


state 103

   55 doWhile: DO CURLY_BRACKET_L stmts . CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_R  shift, and go to state 115


state 104

   56 while: WHILE BRACKET_L expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 116


state 105

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14


state 106

   20 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 20 (funbody)


state 107

   22 funbody: CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R .

    $default  reduce using rule 22 (funbody)


state 108

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 117


state 109

   21 funbody: CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R .

    $default  reduce using rule 21 (funbody)


state 110

   50 assign: varlet LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 118


state 111

   34 vardecl: type ID SEMICOLON .

    $default  reduce using rule 34 (vardecl)


state 112

   27 vardecl: type ID LET . exprs expr SEMICOLON vardecl
   28        | type ID LET . exprs expr SEMICOLON
   29        | type ID LET . exprs SEMICOLON vardecl
   30        | type ID LET . expr SEMICOLON vardecl
   31        | type ID LET . exprs SEMICOLON
   32        | type ID LET . expr SEMICOLON
   33        | type ID LET . SEMICOLON vardecl

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 119
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 120
    exprs     go to state 121
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 113

   45 ifelse: IF BRACKET_L expr BRACKET_R . block ELSE block
   46       | IF BRACKET_L expr BRACKET_R . block
   47       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 122

    block  go to state 123


state 114

   51 for: FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    LET  shift, and go to state 124


state 115

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R . WHILE BRACKET_L expr BRACKET_R SEMICOLON

    WHILE  shift, and go to state 125


state 116

   56 while: WHILE BRACKET_L expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 126


state 117

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 19 (funbody)


state 118

   50 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 50 (assign)


state 119

   33 vardecl: type ID LET SEMICOLON . vardecl

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    vardecl  go to state 127
    type     go to state 128


state 120

   30 vardecl: type ID LET expr . SEMICOLON vardecl
   32        | type ID LET expr . SEMICOLON
   62 exprs: expr .
   63      | expr . exprs

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 129
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 62 (exprs)]
    SEMICOLON  [reduce using rule 62 (exprs)]
    MINUS      [reduce using rule 62 (exprs)]
    NOT        [reduce using rule 62 (exprs)]
    TRUEVAL    [reduce using rule 62 (exprs)]
    FALSEVAL   [reduce using rule 62 (exprs)]
    NUM        [reduce using rule 62 (exprs)]
    FLOAT      [reduce using rule 62 (exprs)]
    ID         [reduce using rule 62 (exprs)]

    expr      go to state 130
    exprs     go to state 131
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 121

   27 vardecl: type ID LET exprs . expr SEMICOLON vardecl
   28        | type ID LET exprs . expr SEMICOLON
   29        | type ID LET exprs . SEMICOLON vardecl
   31        | type ID LET exprs . SEMICOLON

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 132
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 133
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 122

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   49 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 134
    RETURN           shift, and go to state 60
    IF               shift, and go to state 61
    FOR              shift, and go to state 62
    DO               shift, and go to state 63
    WHILE            shift, and go to state 64
    ID               shift, and go to state 65

    stmts    go to state 135
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 123

   45 ifelse: IF BRACKET_L expr BRACKET_R block . ELSE block
   46       | IF BRACKET_L expr BRACKET_R block .

    ELSE  shift, and go to state 136

    $default  reduce using rule 46 (ifelse)


state 124

   51 for: FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 137
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 125

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE . BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 138


state 126

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 60
    IF      shift, and go to state 61
    FOR     shift, and go to state 62
    DO      shift, and go to state 63
    WHILE   shift, and go to state 64
    ID      shift, and go to state 65

    stmts    go to state 139
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 127

   33 vardecl: type ID LET SEMICOLON vardecl .

    $default  reduce using rule 33 (vardecl)


state 128

   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 140


state 129

   30 vardecl: type ID LET expr SEMICOLON . vardecl
   32        | type ID LET expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 32 (vardecl)]
    FLOAT_TYPE  [reduce using rule 32 (vardecl)]
    BOOL_TYPE   [reduce using rule 32 (vardecl)]
    $default    reduce using rule 32 (vardecl)

    vardecl  go to state 141
    type     go to state 128


state 130

   62 exprs: expr .
   63      | expr . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 62 (exprs)]
    MINUS      [reduce using rule 62 (exprs)]
    NOT        [reduce using rule 62 (exprs)]
    TRUEVAL    [reduce using rule 62 (exprs)]
    FALSEVAL   [reduce using rule 62 (exprs)]
    NUM        [reduce using rule 62 (exprs)]
    FLOAT      [reduce using rule 62 (exprs)]
    ID         [reduce using rule 62 (exprs)]
    $default   reduce using rule 62 (exprs)

    expr      go to state 130
    exprs     go to state 131
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 131

   63 exprs: expr exprs .

    $default  reduce using rule 63 (exprs)


state 132

   29 vardecl: type ID LET exprs SEMICOLON . vardecl
   31        | type ID LET exprs SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 31 (vardecl)]
    FLOAT_TYPE  [reduce using rule 31 (vardecl)]
    BOOL_TYPE   [reduce using rule 31 (vardecl)]
    $default    reduce using rule 31 (vardecl)

    vardecl  go to state 142
    type     go to state 128


state 133

   27 vardecl: type ID LET exprs expr . SEMICOLON vardecl
   28        | type ID LET exprs expr . SEMICOLON

    SEMICOLON  shift, and go to state 143


state 134

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    ELSE  shift, and go to state 144

    $default  reduce using rule 48 (ifelse)


state 135

   49 block: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 145


state 136

   45 ifelse: IF BRACKET_L expr BRACKET_R block ELSE . block

    CURLY_BRACKET_L  shift, and go to state 146

    block  go to state 147


state 137

   51 for: FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    COMMA  shift, and go to state 148


state 138

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L . expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 149
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 139

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 150


state 140

   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    SEMICOLON  shift, and go to state 111
    LET        shift, and go to state 112


state 141

   30 vardecl: type ID LET expr SEMICOLON vardecl .

    $default  reduce using rule 30 (vardecl)


state 142

   29 vardecl: type ID LET exprs SEMICOLON vardecl .

    $default  reduce using rule 29 (vardecl)


state 143

   27 vardecl: type ID LET exprs expr SEMICOLON . vardecl
   28        | type ID LET exprs expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 28 (vardecl)]
    FLOAT_TYPE  [reduce using rule 28 (vardecl)]
    BOOL_TYPE   [reduce using rule 28 (vardecl)]
    $default    reduce using rule 28 (vardecl)

    vardecl  go to state 151
    type     go to state 128


state 144

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 152


state 145

   49 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 49 (block)


state 146

   49 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 60
    IF      shift, and go to state 61
    FOR     shift, and go to state 62
    DO      shift, and go to state 63
    WHILE   shift, and go to state 64
    ID      shift, and go to state 65

    stmts    go to state 135
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 147

   45 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block .

    $default  reduce using rule 45 (ifelse)


state 148

   51 for: FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 153
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 149

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr . BRACKET_R SEMICOLON

    BRACKET_R  shift, and go to state 154


state 150

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 56 (while)


state 151

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl .

    $default  reduce using rule 27 (vardecl)


state 152

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 155


state 153

   51 for: FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 156
    COMMA      shift, and go to state 157


state 154

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 158


state 155

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 47 (ifelse)


state 156

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 159


state 157

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 160
    constant  go to state 30
    floatval  go to state 31
    intval    go to state 32
    boolval   go to state 33
    monop     go to state 34


state 158

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON .

    $default  reduce using rule 55 (doWhile)


state 159

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 161
    RETURN           shift, and go to state 60
    IF               shift, and go to state 61
    FOR              shift, and go to state 62
    DO               shift, and go to state 63
    WHILE            shift, and go to state 64
    ID               shift, and go to state 65

    stmts    go to state 162
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 160

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 163


state 161

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 51 (for)


state 162

   53 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 164


state 163

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 165


state 164

   53 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 53 (for)


state 165

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 166
    RETURN           shift, and go to state 60
    IF               shift, and go to state 61
    FOR              shift, and go to state 62
    DO               shift, and go to state 63
    WHILE            shift, and go to state 64
    ID               shift, and go to state 65

    stmts    go to state 167
    stmt     go to state 70
    return   go to state 71
    ifelse   go to state 72
    assign   go to state 73
    for      go to state 74
    doWhile  go to state 75
    while    go to state 76
    varlet   go to state 77


state 166

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 52 (for)


state 167

   54 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 168


state 168

   54 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 54 (for)
