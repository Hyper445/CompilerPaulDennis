Terminals which are not used

   NE
   NEG
   INTTYPE
   FLOATTYPE
   BOOLTYPE


Rules never reduced

   72 exprs: expr exprs


State 28 conflicts: 1 shift/reduce
State 29 conflicts: 9 shift/reduce
State 43 conflicts: 19 shift/reduce
State 47 conflicts: 8 shift/reduce
State 48 conflicts: 28 reduce/reduce
State 49 conflicts: 8 shift/reduce, 28 reduce/reduce
State 54 conflicts: 8 reduce/reduce
State 69 conflicts: 1 shift/reduce
State 76 conflicts: 1 shift/reduce
State 90 conflicts: 8 shift/reduce, 14 reduce/reduce
State 94 conflicts: 9 shift/reduce
State 95 conflicts: 8 shift/reduce, 28 reduce/reduce
State 98 conflicts: 9 shift/reduce
State 116 conflicts: 9 shift/reduce
State 119 conflicts: 9 shift/reduce
State 125 conflicts: 9 shift/reduce
State 135 conflicts: 9 shift/reduce
State 136 conflicts: 9 shift/reduce
State 144 conflicts: 3 shift/reduce
State 145 conflicts: 3 shift/reduce
State 146 conflicts: 9 shift/reduce
State 150 conflicts: 9 shift/reduce
State 156 conflicts: 3 shift/reduce
State 162 conflicts: 9 shift/reduce
State 166 conflicts: 10 shift/reduce
State 173 conflicts: 9 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decls

    2 decls: decl
    3      | decl decls

    4 decl: fundef
    5     | globdef
    6     | globdecl

    7 globdecl: type ID ids SEMICOLON
    8         | type ID SEMICOLON

    9 globdef: type ID LET expr SEMICOLON

   10 fundef: type ID BRACKET_L param BRACKET_R funbody

   11 param: type ID ids param
   12      | type ID ids
   13      | type ID COMMA param
   14      | type ID

   15 fundefs: fundef fundefs
   16        | fundef

   17 ids: ID ids
   18    | ID

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L CURLY_BRACKET_R

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl
   28        | type ID LET exprs expr SEMICOLON
   29        | type ID LET exprs SEMICOLON vardecl
   30        | type ID LET expr SEMICOLON vardecl
   31        | type ID LET exprs SEMICOLON
   32        | type ID LET expr SEMICOLON
   33        | type ID LET SEMICOLON vardecl
   34        | type ID SEMICOLON

   35 stmts: stmt stmts
   36      | stmt

   37 stmt: assign
   38     | return
   39     | ifelse
   40     | for
   41     | dowhile
   42     | while
   43     | exprstmt

   44 return: RETURN expr SEMICOLON
   45       | RETURN SEMICOLON

   46 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block
   47       | IF BRACKET_L expr BRACKET_R block
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

   50 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R

   51 assign: varlet LET expr SEMICOLON

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   58 exprstmt: expr

   59 varlet: ID

   60 expr: constant
   61     | ID
   62     | monop expr
   63     | BRACKET_L expr binop expr BRACKET_R
   64     | cast
   65     | funcall
   66     | arrexpr

   67 cast: BRACKET_L type BRACKET_R expr

   68 funcall: ID BRACKET_L exprs BRACKET_R
   69        | ID BRACKET_L BRACKET_R

   70 arrexpr: exprs

   71 exprs: expr
   72      | expr exprs

   73 constant: floatval
   74         | intval
   75         | boolval

   76 floatval: FLOAT

   77 intval: NUM

   78 boolval: TRUEVAL
   79        | FALSEVAL

   80 binop: PLUS
   81      | MINUS
   82      | STAR
   83      | SLASH
   84      | PERCENT
   85      | LE
   86      | LT
   87      | GE
   88      | GT
   89      | EQ
   90      | OR
   91      | AND

   92 monop: NOT
   93      | MINUS

   94 type: INT_TYPE
   95     | FLOAT_TYPE
   96     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 94
FLOAT_TYPE (259) 95
BOOL_TYPE (260) 96
BRACKET_L (261) 10 46 47 48 49 52 53 54 55 56 57 63 67 68 69
BRACKET_R (262) 10 46 47 48 49 52 53 54 55 56 57 63 67 68 69
COMMA (263) 13 52 53 54 55
SEMICOLON (264) 7 8 9 27 28 29 30 31 32 33 34 44 45 51 56
MINUS (265) 81 93
PLUS (266) 80
STAR (267) 82
SLASH (268) 83
PERCENT (269) 84
LE (270) 85
LT (271) 86
GE (272) 87
GT (273) 88
EQ (274) 89
NE (275)
OR (276) 90
AND (277) 91
NOT (278) 92
NEG (279)
TRUEVAL (280) 78
FALSEVAL (281) 79
LET (282) 9 27 28 29 30 31 32 33 51 52 53 54 55
INTTYPE (283)
FLOATTYPE (284)
BOOLTYPE (285)
CURLY_BRACKET_L (286) 19 20 21 22 23 24 25 26 48 49 50 52 53 54 55
    56 57
CURLY_BRACKET_R (287) 19 20 21 22 23 24 25 26 48 49 50 52 53 54 55
    56 57
RETURN (288) 44 45
IF (289) 46 47 48 49
ELSE (290) 46 48
FOR (291) 52 53 54 55
DO (292) 56
WHILE (293) 56 57
NUM (294) 77
FLOAT (295) 76
ID (296) 7 8 9 10 11 12 13 14 17 18 27 28 29 30 31 32 33 34 52 53 54
    55 59 61 68 69


Nonterminals, with rules where they appear

$accept (42)
    on left: 0
program (43)
    on left: 1, on right: 0
decls (44)
    on left: 2 3, on right: 1 3
decl (45)
    on left: 4 5 6, on right: 2 3
globdecl (46)
    on left: 7 8, on right: 6
globdef (47)
    on left: 9, on right: 5
fundef (48)
    on left: 10, on right: 4 15 16
param (49)
    on left: 11 12 13 14, on right: 10 11 13
fundefs (50)
    on left: 15 16, on right: 15 19 20 22 25
ids (51)
    on left: 17 18, on right: 7 11 12 17
funbody (52)
    on left: 19 20 21 22 23 24 25 26, on right: 10
vardecl (53)
    on left: 27 28 29 30 31 32 33 34, on right: 19 21 22 23 27 29 30
    33
stmts (54)
    on left: 35 36, on right: 19 20 21 24 35 50 54 55 56 57
stmt (55)
    on left: 37 38 39 40 41 42 43, on right: 35 36
return (56)
    on left: 44 45, on right: 38
ifelse (57)
    on left: 46 47 48 49, on right: 39
block (58)
    on left: 50, on right: 46 47
assign (59)
    on left: 51, on right: 37
for (60)
    on left: 52 53 54 55, on right: 40
dowhile (61)
    on left: 56, on right: 41
while (62)
    on left: 57, on right: 42
exprstmt (63)
    on left: 58, on right: 43
varlet (64)
    on left: 59, on right: 51
expr (65)
    on left: 60 61 62 63 64 65 66, on right: 9 27 28 30 32 44 46 47
    48 49 51 52 53 54 55 56 57 58 62 63 67 71 72
cast (66)
    on left: 67, on right: 64
funcall (67)
    on left: 68 69, on right: 65
arrexpr (68)
    on left: 70, on right: 66
exprs (69)
    on left: 71 72, on right: 27 28 29 31 68 70 72
constant (70)
    on left: 73 74 75, on right: 60
floatval (71)
    on left: 76, on right: 73
intval (72)
    on left: 77, on right: 74
boolval (73)
    on left: 78 79, on right: 75
binop (74)
    on left: 80 81 82 83 84 85 86 87 88 89 90 91, on right: 63
monop (75)
    on left: 92 93, on right: 62
type (76)
    on left: 94 95 96, on right: 7 8 9 10 11 12 13 14 27 28 29 30 31
    32 33 34 52 53 54 55 67


state 0

    0 $accept: . program $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    program   go to state 4
    decls     go to state 5
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 1

   94 type: INT_TYPE .

    $default  reduce using rule 94 (type)


state 2

   95 type: FLOAT_TYPE .

    $default  reduce using rule 95 (type)


state 3

   96 type: BOOL_TYPE .

    $default  reduce using rule 96 (type)


state 4

    0 $accept: program . $end

    $end  shift, and go to state 11


state 5

    1 program: decls .

    $default  reduce using rule 1 (program)


state 6

    2 decls: decl .
    3      | decl . decls

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 2 (decls)

    decls     go to state 12
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 7

    6 decl: globdecl .

    $default  reduce using rule 6 (decl)


state 8

    5 decl: globdef .

    $default  reduce using rule 5 (decl)


state 9

    4 decl: fundef .

    $default  reduce using rule 4 (decl)


state 10

    7 globdecl: type . ID ids SEMICOLON
    8         | type . ID SEMICOLON
    9 globdef: type . ID LET expr SEMICOLON
   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 13


state 11

    0 $accept: program $end .

    $default  accept


state 12

    3 decls: decl decls .

    $default  reduce using rule 3 (decls)


state 13

    7 globdecl: type ID . ids SEMICOLON
    8         | type ID . SEMICOLON
    9 globdef: type ID . LET expr SEMICOLON
   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 15
    LET        shift, and go to state 16
    ID         shift, and go to state 17

    ids  go to state 18


state 14

   10 fundef: type ID BRACKET_L . param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 19
    type   go to state 20


state 15

    8 globdecl: type ID SEMICOLON .

    $default  reduce using rule 8 (globdecl)


state 16

    9 globdef: type ID LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 29
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 17

   17 ids: ID . ids
   18    | ID .

    ID  shift, and go to state 17

    $default  reduce using rule 18 (ids)

    ids  go to state 39


state 18

    7 globdecl: type ID ids . SEMICOLON

    SEMICOLON  shift, and go to state 40


state 19

   10 fundef: type ID BRACKET_L param . BRACKET_R funbody

    BRACKET_R  shift, and go to state 41


state 20

   11 param: type . ID ids param
   12      | type . ID ids
   13      | type . ID COMMA param
   14      | type . ID

    ID  shift, and go to state 42


state 21

   63 expr: BRACKET_L . expr binop expr BRACKET_R
   67 cast: BRACKET_L . type BRACKET_R expr

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    BRACKET_L   shift, and go to state 21
    MINUS       shift, and go to state 22
    NOT         shift, and go to state 23
    TRUEVAL     shift, and go to state 24
    FALSEVAL    shift, and go to state 25
    NUM         shift, and go to state 26
    FLOAT       shift, and go to state 27
    ID          shift, and go to state 28

    expr      go to state 43
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38
    type      go to state 44


state 22

   93 monop: MINUS .

    $default  reduce using rule 93 (monop)


state 23

   92 monop: NOT .

    $default  reduce using rule 92 (monop)


state 24

   78 boolval: TRUEVAL .

    $default  reduce using rule 78 (boolval)


state 25

   79 boolval: FALSEVAL .

    $default  reduce using rule 79 (boolval)


state 26

   77 intval: NUM .

    $default  reduce using rule 77 (intval)


state 27

   76 floatval: FLOAT .

    $default  reduce using rule 76 (floatval)


state 28

   61 expr: ID .
   68 funcall: ID . BRACKET_L exprs BRACKET_R
   69        | ID . BRACKET_L BRACKET_R

    BRACKET_L  shift, and go to state 45

    BRACKET_L  [reduce using rule 61 (expr)]
    $default   reduce using rule 61 (expr)


state 29

    9 globdef: type ID LET expr . SEMICOLON
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 46
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 30

   64 expr: cast .

    $default  reduce using rule 64 (expr)


state 31

   65 expr: funcall .

    $default  reduce using rule 65 (expr)


state 32

   66 expr: arrexpr .

    $default  reduce using rule 66 (expr)


state 33

   70 arrexpr: exprs .

    $default  reduce using rule 70 (arrexpr)


state 34

   60 expr: constant .

    $default  reduce using rule 60 (expr)


state 35

   73 constant: floatval .

    $default  reduce using rule 73 (constant)


state 36

   74 constant: intval .

    $default  reduce using rule 74 (constant)


state 37

   75 constant: boolval .

    $default  reduce using rule 75 (constant)


state 38

   62 expr: monop . expr

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 49
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 39

   17 ids: ID ids .

    $default  reduce using rule 17 (ids)


state 40

    7 globdecl: type ID ids SEMICOLON .

    $default  reduce using rule 7 (globdecl)


state 41

   10 fundef: type ID BRACKET_L param BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 50

    funbody  go to state 51


state 42

   11 param: type ID . ids param
   12      | type ID . ids
   13      | type ID . COMMA param
   14      | type ID .

    COMMA  shift, and go to state 52
    ID     shift, and go to state 17

    $default  reduce using rule 14 (param)

    ids  go to state 53


state 43

   63 expr: BRACKET_L expr . binop expr BRACKET_R
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 54
    PLUS       shift, and go to state 55
    STAR       shift, and go to state 56
    SLASH      shift, and go to state 57
    PERCENT    shift, and go to state 58
    LE         shift, and go to state 59
    LT         shift, and go to state 60
    GE         shift, and go to state 61
    GT         shift, and go to state 62
    EQ         shift, and go to state 63
    OR         shift, and go to state 64
    AND        shift, and go to state 65
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    PLUS       [reduce using rule 71 (exprs)]
    STAR       [reduce using rule 71 (exprs)]
    SLASH      [reduce using rule 71 (exprs)]
    PERCENT    [reduce using rule 71 (exprs)]
    LE         [reduce using rule 71 (exprs)]
    LT         [reduce using rule 71 (exprs)]
    GE         [reduce using rule 71 (exprs)]
    GT         [reduce using rule 71 (exprs)]
    EQ         [reduce using rule 71 (exprs)]
    OR         [reduce using rule 71 (exprs)]
    AND        [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    binop     go to state 66
    monop     go to state 38


state 44

   67 cast: BRACKET_L type . BRACKET_R expr

    BRACKET_R  shift, and go to state 67


state 45

   68 funcall: ID BRACKET_L . exprs BRACKET_R
   69        | ID BRACKET_L . BRACKET_R

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 68
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 69
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 46

    9 globdef: type ID LET expr SEMICOLON .

    $default  reduce using rule 9 (globdef)


state 47

   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]
    $default   reduce using rule 71 (exprs)

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 48

   70 arrexpr: exprs .
   72 exprs: expr exprs .

    BRACKET_L        reduce using rule 70 (arrexpr)
    BRACKET_L        [reduce using rule 72 (exprs)]
    BRACKET_R        reduce using rule 70 (arrexpr)
    BRACKET_R        [reduce using rule 72 (exprs)]
    COMMA            reduce using rule 70 (arrexpr)
    COMMA            [reduce using rule 72 (exprs)]
    SEMICOLON        reduce using rule 70 (arrexpr)
    SEMICOLON        [reduce using rule 72 (exprs)]
    MINUS            reduce using rule 70 (arrexpr)
    MINUS            [reduce using rule 72 (exprs)]
    PLUS             reduce using rule 70 (arrexpr)
    PLUS             [reduce using rule 72 (exprs)]
    STAR             reduce using rule 70 (arrexpr)
    STAR             [reduce using rule 72 (exprs)]
    SLASH            reduce using rule 70 (arrexpr)
    SLASH            [reduce using rule 72 (exprs)]
    PERCENT          reduce using rule 70 (arrexpr)
    PERCENT          [reduce using rule 72 (exprs)]
    LE               reduce using rule 70 (arrexpr)
    LE               [reduce using rule 72 (exprs)]
    LT               reduce using rule 70 (arrexpr)
    LT               [reduce using rule 72 (exprs)]
    GE               reduce using rule 70 (arrexpr)
    GE               [reduce using rule 72 (exprs)]
    GT               reduce using rule 70 (arrexpr)
    GT               [reduce using rule 72 (exprs)]
    EQ               reduce using rule 70 (arrexpr)
    EQ               [reduce using rule 72 (exprs)]
    OR               reduce using rule 70 (arrexpr)
    OR               [reduce using rule 72 (exprs)]
    AND              reduce using rule 70 (arrexpr)
    AND              [reduce using rule 72 (exprs)]
    NOT              reduce using rule 70 (arrexpr)
    NOT              [reduce using rule 72 (exprs)]
    TRUEVAL          reduce using rule 70 (arrexpr)
    TRUEVAL          [reduce using rule 72 (exprs)]
    FALSEVAL         reduce using rule 70 (arrexpr)
    FALSEVAL         [reduce using rule 72 (exprs)]
    CURLY_BRACKET_R  reduce using rule 70 (arrexpr)
    CURLY_BRACKET_R  [reduce using rule 72 (exprs)]
    RETURN           reduce using rule 70 (arrexpr)
    RETURN           [reduce using rule 72 (exprs)]
    IF               reduce using rule 70 (arrexpr)
    IF               [reduce using rule 72 (exprs)]
    FOR              reduce using rule 70 (arrexpr)
    FOR              [reduce using rule 72 (exprs)]
    DO               reduce using rule 70 (arrexpr)
    DO               [reduce using rule 72 (exprs)]
    WHILE            reduce using rule 70 (arrexpr)
    WHILE            [reduce using rule 72 (exprs)]
    NUM              reduce using rule 70 (arrexpr)
    NUM              [reduce using rule 72 (exprs)]
    FLOAT            reduce using rule 70 (arrexpr)
    FLOAT            [reduce using rule 72 (exprs)]
    ID               reduce using rule 70 (arrexpr)
    ID               [reduce using rule 72 (exprs)]
    $default         reduce using rule 70 (arrexpr)


state 49

   62 expr: monop expr .
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L        [reduce using rule 62 (expr)]
    BRACKET_L        [reduce using rule 71 (exprs)]
    BRACKET_R        reduce using rule 62 (expr)
    BRACKET_R        [reduce using rule 71 (exprs)]
    COMMA            reduce using rule 62 (expr)
    COMMA            [reduce using rule 71 (exprs)]
    SEMICOLON        reduce using rule 62 (expr)
    SEMICOLON        [reduce using rule 71 (exprs)]
    MINUS            [reduce using rule 62 (expr)]
    MINUS            [reduce using rule 71 (exprs)]
    PLUS             reduce using rule 62 (expr)
    PLUS             [reduce using rule 71 (exprs)]
    STAR             reduce using rule 62 (expr)
    STAR             [reduce using rule 71 (exprs)]
    SLASH            reduce using rule 62 (expr)
    SLASH            [reduce using rule 71 (exprs)]
    PERCENT          reduce using rule 62 (expr)
    PERCENT          [reduce using rule 71 (exprs)]
    LE               reduce using rule 62 (expr)
    LE               [reduce using rule 71 (exprs)]
    LT               reduce using rule 62 (expr)
    LT               [reduce using rule 71 (exprs)]
    GE               reduce using rule 62 (expr)
    GE               [reduce using rule 71 (exprs)]
    GT               reduce using rule 62 (expr)
    GT               [reduce using rule 71 (exprs)]
    EQ               reduce using rule 62 (expr)
    EQ               [reduce using rule 71 (exprs)]
    OR               reduce using rule 62 (expr)
    OR               [reduce using rule 71 (exprs)]
    AND              reduce using rule 62 (expr)
    AND              [reduce using rule 71 (exprs)]
    NOT              [reduce using rule 62 (expr)]
    NOT              [reduce using rule 71 (exprs)]
    TRUEVAL          [reduce using rule 62 (expr)]
    TRUEVAL          [reduce using rule 71 (exprs)]
    FALSEVAL         [reduce using rule 62 (expr)]
    FALSEVAL         [reduce using rule 71 (exprs)]
    CURLY_BRACKET_R  reduce using rule 62 (expr)
    CURLY_BRACKET_R  [reduce using rule 71 (exprs)]
    RETURN           reduce using rule 62 (expr)
    RETURN           [reduce using rule 71 (exprs)]
    IF               reduce using rule 62 (expr)
    IF               [reduce using rule 71 (exprs)]
    FOR              reduce using rule 62 (expr)
    FOR              [reduce using rule 71 (exprs)]
    DO               reduce using rule 62 (expr)
    DO               [reduce using rule 71 (exprs)]
    WHILE            reduce using rule 62 (expr)
    WHILE            [reduce using rule 71 (exprs)]
    NUM              [reduce using rule 62 (expr)]
    NUM              [reduce using rule 71 (exprs)]
    FLOAT            [reduce using rule 62 (expr)]
    FLOAT            [reduce using rule 71 (exprs)]
    ID               [reduce using rule 62 (expr)]
    ID               [reduce using rule 71 (exprs)]
    $default         reduce using rule 62 (expr)

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 50

   19 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 70
    RETURN           shift, and go to state 71
    IF               shift, and go to state 72
    FOR              shift, and go to state 73
    DO               shift, and go to state 74
    WHILE            shift, and go to state 75
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 76

    fundef    go to state 77
    fundefs   go to state 78
    vardecl   go to state 79
    stmts     go to state 80
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38
    type      go to state 91


state 51

   10 fundef: type ID BRACKET_L param BRACKET_R funbody .

    $default  reduce using rule 10 (fundef)


state 52

   13 param: type ID COMMA . param

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 92
    type   go to state 20


state 53

   11 param: type ID ids . param
   12      | type ID ids .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 12 (param)

    param  go to state 93
    type   go to state 20


state 54

   81 binop: MINUS .
   93 monop: MINUS .

    BRACKET_L  reduce using rule 81 (binop)
    BRACKET_L  [reduce using rule 93 (monop)]
    MINUS      reduce using rule 81 (binop)
    MINUS      [reduce using rule 93 (monop)]
    NOT        reduce using rule 81 (binop)
    NOT        [reduce using rule 93 (monop)]
    TRUEVAL    reduce using rule 81 (binop)
    TRUEVAL    [reduce using rule 93 (monop)]
    FALSEVAL   reduce using rule 81 (binop)
    FALSEVAL   [reduce using rule 93 (monop)]
    NUM        reduce using rule 81 (binop)
    NUM        [reduce using rule 93 (monop)]
    FLOAT      reduce using rule 81 (binop)
    FLOAT      [reduce using rule 93 (monop)]
    ID         reduce using rule 81 (binop)
    ID         [reduce using rule 93 (monop)]
    $default   reduce using rule 81 (binop)


state 55

   80 binop: PLUS .

    $default  reduce using rule 80 (binop)


state 56

   82 binop: STAR .

    $default  reduce using rule 82 (binop)


state 57

   83 binop: SLASH .

    $default  reduce using rule 83 (binop)


state 58

   84 binop: PERCENT .

    $default  reduce using rule 84 (binop)


state 59

   85 binop: LE .

    $default  reduce using rule 85 (binop)


state 60

   86 binop: LT .

    $default  reduce using rule 86 (binop)


state 61

   87 binop: GE .

    $default  reduce using rule 87 (binop)


state 62

   88 binop: GT .

    $default  reduce using rule 88 (binop)


state 63

   89 binop: EQ .

    $default  reduce using rule 89 (binop)


state 64

   90 binop: OR .

    $default  reduce using rule 90 (binop)


state 65

   91 binop: AND .

    $default  reduce using rule 91 (binop)


state 66

   63 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 94
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 67

   67 cast: BRACKET_L type BRACKET_R . expr

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 95
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 68

   69 funcall: ID BRACKET_L BRACKET_R .

    $default  reduce using rule 69 (funcall)


state 69

   68 funcall: ID BRACKET_L exprs . BRACKET_R
   70 arrexpr: exprs .

    BRACKET_R  shift, and go to state 96

    BRACKET_R  [reduce using rule 70 (arrexpr)]
    $default   reduce using rule 70 (arrexpr)


state 70

   26 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 26 (funbody)


state 71

   44 return: RETURN . expr SEMICOLON
   45       | RETURN . SEMICOLON

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 97
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 98
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 72

   46 ifelse: IF . BRACKET_L expr BRACKET_R block ELSE block
   47       | IF . BRACKET_L expr BRACKET_R block
   48       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 99


state 73

   52 for: FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 100


state 74

   56 dowhile: DO . CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_L  shift, and go to state 101


state 75

   57 while: WHILE . BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 102


state 76

   59 varlet: ID .
   61 expr: ID .
   68 funcall: ID . BRACKET_L exprs BRACKET_R
   69        | ID . BRACKET_L BRACKET_R

    BRACKET_L  shift, and go to state 45

    BRACKET_L  [reduce using rule 61 (expr)]
    LET        reduce using rule 59 (varlet)
    $default   reduce using rule 61 (expr)


state 77

   15 fundefs: fundef . fundefs
   16        | fundef .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 16 (fundefs)

    fundef   go to state 77
    fundefs  go to state 103
    type     go to state 104


state 78

   20 funbody: CURLY_BRACKET_L fundefs . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs . CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 105
    RETURN           shift, and go to state 71
    IF               shift, and go to state 72
    FOR              shift, and go to state 73
    DO               shift, and go to state 74
    WHILE            shift, and go to state 75
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 76

    stmts     go to state 106
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 79

   19 funbody: CURLY_BRACKET_L vardecl . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl . fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 107
    RETURN           shift, and go to state 71
    IF               shift, and go to state 72
    FOR              shift, and go to state 73
    DO               shift, and go to state 74
    WHILE            shift, and go to state 75
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 76

    fundef    go to state 77
    fundefs   go to state 108
    stmts     go to state 109
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38
    type      go to state 104


state 80

   24 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 110


state 81

   35 stmts: stmt . stmts
   36      | stmt .

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 71
    IF         shift, and go to state 72
    FOR        shift, and go to state 73
    DO         shift, and go to state 74
    WHILE      shift, and go to state 75
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 76

    $default  reduce using rule 36 (stmts)

    stmts     go to state 111
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 82

   38 stmt: return .

    $default  reduce using rule 38 (stmt)


state 83

   39 stmt: ifelse .

    $default  reduce using rule 39 (stmt)


state 84

   37 stmt: assign .

    $default  reduce using rule 37 (stmt)


state 85

   40 stmt: for .

    $default  reduce using rule 40 (stmt)


state 86

   41 stmt: dowhile .

    $default  reduce using rule 41 (stmt)


state 87

   42 stmt: while .

    $default  reduce using rule 42 (stmt)


state 88

   43 stmt: exprstmt .

    $default  reduce using rule 43 (stmt)


state 89

   51 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 112


state 90

   58 exprstmt: expr .
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L        [reduce using rule 58 (exprstmt)]
    BRACKET_L        [reduce using rule 71 (exprs)]
    MINUS            [reduce using rule 58 (exprstmt)]
    MINUS            [reduce using rule 71 (exprs)]
    NOT              [reduce using rule 58 (exprstmt)]
    NOT              [reduce using rule 71 (exprs)]
    TRUEVAL          [reduce using rule 58 (exprstmt)]
    TRUEVAL          [reduce using rule 71 (exprs)]
    FALSEVAL         [reduce using rule 58 (exprstmt)]
    FALSEVAL         [reduce using rule 71 (exprs)]
    CURLY_BRACKET_R  reduce using rule 58 (exprstmt)
    CURLY_BRACKET_R  [reduce using rule 71 (exprs)]
    RETURN           reduce using rule 58 (exprstmt)
    RETURN           [reduce using rule 71 (exprs)]
    IF               reduce using rule 58 (exprstmt)
    IF               [reduce using rule 71 (exprs)]
    FOR              reduce using rule 58 (exprstmt)
    FOR              [reduce using rule 71 (exprs)]
    DO               reduce using rule 58 (exprstmt)
    DO               [reduce using rule 71 (exprs)]
    WHILE            reduce using rule 58 (exprstmt)
    WHILE            [reduce using rule 71 (exprs)]
    NUM              [reduce using rule 58 (exprstmt)]
    NUM              [reduce using rule 71 (exprs)]
    FLOAT            [reduce using rule 58 (exprstmt)]
    FLOAT            [reduce using rule 71 (exprs)]
    ID               [reduce using rule 58 (exprstmt)]
    ID               [reduce using rule 71 (exprs)]
    $default         reduce using rule 58 (exprstmt)

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 91

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody
   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 113


state 92

   13 param: type ID COMMA param .

    $default  reduce using rule 13 (param)


state 93

   11 param: type ID ids param .

    $default  reduce using rule 11 (param)


state 94

   63 expr: BRACKET_L expr binop expr . BRACKET_R
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 114
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    BRACKET_R  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 95

   67 cast: BRACKET_L type BRACKET_R expr .
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L        [reduce using rule 67 (cast)]
    BRACKET_L        [reduce using rule 71 (exprs)]
    BRACKET_R        reduce using rule 67 (cast)
    BRACKET_R        [reduce using rule 71 (exprs)]
    COMMA            reduce using rule 67 (cast)
    COMMA            [reduce using rule 71 (exprs)]
    SEMICOLON        reduce using rule 67 (cast)
    SEMICOLON        [reduce using rule 71 (exprs)]
    MINUS            [reduce using rule 67 (cast)]
    MINUS            [reduce using rule 71 (exprs)]
    PLUS             reduce using rule 67 (cast)
    PLUS             [reduce using rule 71 (exprs)]
    STAR             reduce using rule 67 (cast)
    STAR             [reduce using rule 71 (exprs)]
    SLASH            reduce using rule 67 (cast)
    SLASH            [reduce using rule 71 (exprs)]
    PERCENT          reduce using rule 67 (cast)
    PERCENT          [reduce using rule 71 (exprs)]
    LE               reduce using rule 67 (cast)
    LE               [reduce using rule 71 (exprs)]
    LT               reduce using rule 67 (cast)
    LT               [reduce using rule 71 (exprs)]
    GE               reduce using rule 67 (cast)
    GE               [reduce using rule 71 (exprs)]
    GT               reduce using rule 67 (cast)
    GT               [reduce using rule 71 (exprs)]
    EQ               reduce using rule 67 (cast)
    EQ               [reduce using rule 71 (exprs)]
    OR               reduce using rule 67 (cast)
    OR               [reduce using rule 71 (exprs)]
    AND              reduce using rule 67 (cast)
    AND              [reduce using rule 71 (exprs)]
    NOT              [reduce using rule 67 (cast)]
    NOT              [reduce using rule 71 (exprs)]
    TRUEVAL          [reduce using rule 67 (cast)]
    TRUEVAL          [reduce using rule 71 (exprs)]
    FALSEVAL         [reduce using rule 67 (cast)]
    FALSEVAL         [reduce using rule 71 (exprs)]
    CURLY_BRACKET_R  reduce using rule 67 (cast)
    CURLY_BRACKET_R  [reduce using rule 71 (exprs)]
    RETURN           reduce using rule 67 (cast)
    RETURN           [reduce using rule 71 (exprs)]
    IF               reduce using rule 67 (cast)
    IF               [reduce using rule 71 (exprs)]
    FOR              reduce using rule 67 (cast)
    FOR              [reduce using rule 71 (exprs)]
    DO               reduce using rule 67 (cast)
    DO               [reduce using rule 71 (exprs)]
    WHILE            reduce using rule 67 (cast)
    WHILE            [reduce using rule 71 (exprs)]
    NUM              [reduce using rule 67 (cast)]
    NUM              [reduce using rule 71 (exprs)]
    FLOAT            [reduce using rule 67 (cast)]
    FLOAT            [reduce using rule 71 (exprs)]
    ID               [reduce using rule 67 (cast)]
    ID               [reduce using rule 71 (exprs)]
    $default         reduce using rule 67 (cast)

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 96

   68 funcall: ID BRACKET_L exprs BRACKET_R .

    $default  reduce using rule 68 (funcall)


state 97

   45 return: RETURN SEMICOLON .

    $default  reduce using rule 45 (return)


state 98

   44 return: RETURN expr . SEMICOLON
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 115
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 99

   46 ifelse: IF BRACKET_L . expr BRACKET_R block ELSE block
   47       | IF BRACKET_L . expr BRACKET_R block
   48       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 116
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 100

   52 for: FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 117


state 101

   56 dowhile: DO CURLY_BRACKET_L . stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 71
    IF         shift, and go to state 72
    FOR        shift, and go to state 73
    DO         shift, and go to state 74
    WHILE      shift, and go to state 75
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 76

    stmts     go to state 118
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 102

   57 while: WHILE BRACKET_L . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 119
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 103

   15 fundefs: fundef fundefs .

    $default  reduce using rule 15 (fundefs)


state 104

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 120


state 105

   25 funbody: CURLY_BRACKET_L fundefs CURLY_BRACKET_R .

    $default  reduce using rule 25 (funbody)


state 106

   20 funbody: CURLY_BRACKET_L fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 121


state 107

   23 funbody: CURLY_BRACKET_L vardecl CURLY_BRACKET_R .

    $default  reduce using rule 23 (funbody)


state 108

   19 funbody: CURLY_BRACKET_L vardecl fundefs . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs . CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 122
    RETURN           shift, and go to state 71
    IF               shift, and go to state 72
    FOR              shift, and go to state 73
    DO               shift, and go to state 74
    WHILE            shift, and go to state 75
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 76

    stmts     go to state 123
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 109

   21 funbody: CURLY_BRACKET_L vardecl stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 124


state 110

   24 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 24 (funbody)


state 111

   35 stmts: stmt stmts .

    $default  reduce using rule 35 (stmts)


state 112

   51 assign: varlet LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 125
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 113

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody
   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 126
    LET        shift, and go to state 127


state 114

   63 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 63 (expr)


state 115

   44 return: RETURN expr SEMICOLON .

    $default  reduce using rule 44 (return)


state 116

   46 ifelse: IF BRACKET_L expr . BRACKET_R block ELSE block
   47       | IF BRACKET_L expr . BRACKET_R block
   48       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 128
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    BRACKET_R  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 117

   52 for: FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    ID  shift, and go to state 129


state 118

   56 dowhile: DO CURLY_BRACKET_L stmts . CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_R  shift, and go to state 130


state 119

   57 while: WHILE BRACKET_L expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 131
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    BRACKET_R  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 120

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14


state 121

   20 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 20 (funbody)


state 122

   22 funbody: CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R .

    $default  reduce using rule 22 (funbody)


state 123

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 132


state 124

   21 funbody: CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R .

    $default  reduce using rule 21 (funbody)


state 125

   51 assign: varlet LET expr . SEMICOLON
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 133
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 126

   34 vardecl: type ID SEMICOLON .

    $default  reduce using rule 34 (vardecl)


state 127

   27 vardecl: type ID LET . exprs expr SEMICOLON vardecl
   28        | type ID LET . exprs expr SEMICOLON
   29        | type ID LET . exprs SEMICOLON vardecl
   30        | type ID LET . expr SEMICOLON vardecl
   31        | type ID LET . exprs SEMICOLON
   32        | type ID LET . expr SEMICOLON
   33        | type ID LET . SEMICOLON vardecl

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 134
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 135
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 136
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 128

   46 ifelse: IF BRACKET_L expr BRACKET_R . block ELSE block
   47       | IF BRACKET_L expr BRACKET_R . block
   48       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 137

    block  go to state 138


state 129

   52 for: FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    LET  shift, and go to state 139


state 130

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R . WHILE BRACKET_L expr BRACKET_R SEMICOLON

    WHILE  shift, and go to state 140


state 131

   57 while: WHILE BRACKET_L expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 141


state 132

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 19 (funbody)


state 133

   51 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 51 (assign)


state 134

   33 vardecl: type ID LET SEMICOLON . vardecl

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    vardecl  go to state 142
    type     go to state 143


state 135

   30 vardecl: type ID LET expr . SEMICOLON vardecl
   32        | type ID LET expr . SEMICOLON
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 144
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 136

   27 vardecl: type ID LET exprs . expr SEMICOLON vardecl
   28        | type ID LET exprs . expr SEMICOLON
   29        | type ID LET exprs . SEMICOLON vardecl
   31        | type ID LET exprs . SEMICOLON
   70 arrexpr: exprs .

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 145
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 70 (arrexpr)]
    SEMICOLON  [reduce using rule 70 (arrexpr)]
    MINUS      [reduce using rule 70 (arrexpr)]
    NOT        [reduce using rule 70 (arrexpr)]
    TRUEVAL    [reduce using rule 70 (arrexpr)]
    FALSEVAL   [reduce using rule 70 (arrexpr)]
    NUM        [reduce using rule 70 (arrexpr)]
    FLOAT      [reduce using rule 70 (arrexpr)]
    ID         [reduce using rule 70 (arrexpr)]

    expr      go to state 146
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 137

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   50 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 147
    RETURN           shift, and go to state 71
    IF               shift, and go to state 72
    FOR              shift, and go to state 73
    DO               shift, and go to state 74
    WHILE            shift, and go to state 75
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 76

    stmts     go to state 148
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 138

   46 ifelse: IF BRACKET_L expr BRACKET_R block . ELSE block
   47       | IF BRACKET_L expr BRACKET_R block .

    ELSE  shift, and go to state 149

    $default  reduce using rule 47 (ifelse)


state 139

   52 for: FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 150
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 140

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE . BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 151


state 141

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 71
    IF         shift, and go to state 72
    FOR        shift, and go to state 73
    DO         shift, and go to state 74
    WHILE      shift, and go to state 75
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 76

    stmts     go to state 152
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 142

   33 vardecl: type ID LET SEMICOLON vardecl .

    $default  reduce using rule 33 (vardecl)


state 143

   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 153


state 144

   30 vardecl: type ID LET expr SEMICOLON . vardecl
   32        | type ID LET expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 32 (vardecl)]
    FLOAT_TYPE  [reduce using rule 32 (vardecl)]
    BOOL_TYPE   [reduce using rule 32 (vardecl)]
    $default    reduce using rule 32 (vardecl)

    vardecl  go to state 154
    type     go to state 143


state 145

   29 vardecl: type ID LET exprs SEMICOLON . vardecl
   31        | type ID LET exprs SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 31 (vardecl)]
    FLOAT_TYPE  [reduce using rule 31 (vardecl)]
    BOOL_TYPE   [reduce using rule 31 (vardecl)]
    $default    reduce using rule 31 (vardecl)

    vardecl  go to state 155
    type     go to state 143


state 146

   27 vardecl: type ID LET exprs expr . SEMICOLON vardecl
   28        | type ID LET exprs expr . SEMICOLON
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 156
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 147

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    ELSE  shift, and go to state 157

    $default  reduce using rule 49 (ifelse)


state 148

   50 block: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 158


state 149

   46 ifelse: IF BRACKET_L expr BRACKET_R block ELSE . block

    CURLY_BRACKET_L  shift, and go to state 159

    block  go to state 160


state 150

   52 for: FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    COMMA      shift, and go to state 161
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 151

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L . expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 162
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 152

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 163


state 153

   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    SEMICOLON  shift, and go to state 126
    LET        shift, and go to state 127


state 154

   30 vardecl: type ID LET expr SEMICOLON vardecl .

    $default  reduce using rule 30 (vardecl)


state 155

   29 vardecl: type ID LET exprs SEMICOLON vardecl .

    $default  reduce using rule 29 (vardecl)


state 156

   27 vardecl: type ID LET exprs expr SEMICOLON . vardecl
   28        | type ID LET exprs expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 28 (vardecl)]
    FLOAT_TYPE  [reduce using rule 28 (vardecl)]
    BOOL_TYPE   [reduce using rule 28 (vardecl)]
    $default    reduce using rule 28 (vardecl)

    vardecl  go to state 164
    type     go to state 143


state 157

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 165


state 158

   50 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 50 (block)


state 159

   50 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 71
    IF         shift, and go to state 72
    FOR        shift, and go to state 73
    DO         shift, and go to state 74
    WHILE      shift, and go to state 75
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 76

    stmts     go to state 148
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 160

   46 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block .

    $default  reduce using rule 46 (ifelse)


state 161

   52 for: FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 166
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 162

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr . BRACKET_R SEMICOLON
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 167
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    BRACKET_R  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 163

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 57 (while)


state 164

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl .

    $default  reduce using rule 27 (vardecl)


state 165

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 168


state 166

   52 for: FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 169
    COMMA      shift, and go to state 170
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    BRACKET_R  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 167

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 171


state 168

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 48 (ifelse)


state 169

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 172


state 170

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 173
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 171

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON .

    $default  reduce using rule 56 (dowhile)


state 172

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 174
    RETURN           shift, and go to state 71
    IF               shift, and go to state 72
    FOR              shift, and go to state 73
    DO               shift, and go to state 74
    WHILE            shift, and go to state 75
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 76

    stmts     go to state 175
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 173

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . exprs

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 176
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 71 (exprs)]
    BRACKET_R  [reduce using rule 71 (exprs)]
    MINUS      [reduce using rule 71 (exprs)]
    NOT        [reduce using rule 71 (exprs)]
    TRUEVAL    [reduce using rule 71 (exprs)]
    FALSEVAL   [reduce using rule 71 (exprs)]
    NUM        [reduce using rule 71 (exprs)]
    FLOAT      [reduce using rule 71 (exprs)]
    ID         [reduce using rule 71 (exprs)]

    expr      go to state 47
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 174

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 52 (for)


state 175

   54 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 177


state 176

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 178


state 177

   54 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 54 (for)


state 178

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 179
    RETURN           shift, and go to state 71
    IF               shift, and go to state 72
    FOR              shift, and go to state 73
    DO               shift, and go to state 74
    WHILE            shift, and go to state 75
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 76

    stmts     go to state 180
    stmt      go to state 81
    return    go to state 82
    ifelse    go to state 83
    assign    go to state 84
    for       go to state 85
    dowhile   go to state 86
    while     go to state 87
    exprstmt  go to state 88
    varlet    go to state 89
    expr      go to state 90
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 179

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 53 (for)


state 180

   55 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 181


state 181

   55 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 55 (for)
