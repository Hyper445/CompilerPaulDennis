Terminals which are not used

   NE
   NEG
   INTTYPE
   FLOATTYPE
   BOOLTYPE


Rules never reduced

   72 exprs: expr COMMA exprs


State 28 conflicts: 1 shift/reduce
State 29 conflicts: 2 shift/reduce
State 43 conflicts: 13 shift/reduce
State 48 conflicts: 1 shift/reduce, 28 reduce/reduce
State 68 conflicts: 1 shift/reduce
State 69 conflicts: 1 shift/reduce
State 70 conflicts: 28 reduce/reduce
State 77 conflicts: 1 shift/reduce
State 91 conflicts: 1 shift/reduce, 14 reduce/reduce
State 95 conflicts: 2 shift/reduce
State 96 conflicts: 2 shift/reduce
State 99 conflicts: 2 shift/reduce
State 119 conflicts: 2 shift/reduce
State 122 conflicts: 2 shift/reduce
State 128 conflicts: 2 shift/reduce
State 138 conflicts: 2 shift/reduce
State 139 conflicts: 9 shift/reduce
State 147 conflicts: 3 shift/reduce
State 148 conflicts: 3 shift/reduce
State 149 conflicts: 2 shift/reduce
State 153 conflicts: 1 shift/reduce
State 159 conflicts: 3 shift/reduce
State 165 conflicts: 2 shift/reduce
State 169 conflicts: 2 shift/reduce
State 176 conflicts: 2 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decls

    2 decls: decl
    3      | decl decls

    4 decl: fundef
    5     | globdef
    6     | globdecl

    7 globdecl: type ID ids SEMICOLON
    8         | type ID SEMICOLON

    9 globdef: type ID LET expr SEMICOLON

   10 fundef: type ID BRACKET_L param BRACKET_R funbody

   11 param: type ID ids param
   12      | type ID ids
   13      | type ID COMMA param
   14      | type ID

   15 fundefs: fundef fundefs
   16        | fundef

   17 ids: ID ids
   18    | ID

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L CURLY_BRACKET_R

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl
   28        | type ID LET exprs expr SEMICOLON
   29        | type ID LET exprs SEMICOLON vardecl
   30        | type ID LET expr SEMICOLON vardecl
   31        | type ID LET exprs SEMICOLON
   32        | type ID LET expr SEMICOLON
   33        | type ID LET SEMICOLON vardecl
   34        | type ID SEMICOLON

   35 stmts: stmt stmts
   36      | stmt

   37 stmt: assign
   38     | return
   39     | ifelse
   40     | for
   41     | dowhile
   42     | while
   43     | exprstmt

   44 return: RETURN expr SEMICOLON
   45       | RETURN SEMICOLON

   46 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block
   47       | IF BRACKET_L expr BRACKET_R block
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

   50 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R

   51 assign: varlet LET expr SEMICOLON

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   58 exprstmt: expr

   59 varlet: ID

   60 expr: constant
   61     | ID
   62     | monop expr
   63     | BRACKET_L expr binop expr BRACKET_R
   64     | cast
   65     | funcall
   66     | arrexpr

   67 cast: BRACKET_L type BRACKET_R expr SEMICOLON

   68 funcall: ID BRACKET_L exprs BRACKET_R SEMICOLON
   69        | ID BRACKET_L BRACKET_R

   70 arrexpr: exprs

   71 exprs: expr
   72      | expr COMMA exprs

   73 constant: floatval
   74         | intval
   75         | boolval

   76 floatval: FLOAT

   77 intval: NUM

   78 boolval: TRUEVAL
   79        | FALSEVAL

   80 binop: PLUS
   81      | MINUS
   82      | STAR
   83      | SLASH
   84      | PERCENT
   85      | LE
   86      | LT
   87      | GE
   88      | GT
   89      | EQ
   90      | OR
   91      | AND

   92 monop: NOT
   93      | MINUS

   94 type: INT_TYPE
   95     | FLOAT_TYPE
   96     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 94
FLOAT_TYPE (259) 95
BOOL_TYPE (260) 96
BRACKET_L (261) 10 46 47 48 49 52 53 54 55 56 57 63 67 68 69
BRACKET_R (262) 10 46 47 48 49 52 53 54 55 56 57 63 67 68 69
COMMA (263) 13 52 53 54 55 72
SEMICOLON (264) 7 8 9 27 28 29 30 31 32 33 34 44 45 51 56 67 68
MINUS (265) 81 93
PLUS (266) 80
STAR (267) 82
SLASH (268) 83
PERCENT (269) 84
LE (270) 85
LT (271) 86
GE (272) 87
GT (273) 88
EQ (274) 89
NE (275)
OR (276) 90
AND (277) 91
NOT (278) 92
NEG (279)
TRUEVAL (280) 78
FALSEVAL (281) 79
LET (282) 9 27 28 29 30 31 32 33 51 52 53 54 55
INTTYPE (283)
FLOATTYPE (284)
BOOLTYPE (285)
CURLY_BRACKET_L (286) 19 20 21 22 23 24 25 26 48 49 50 52 53 54 55
    56 57
CURLY_BRACKET_R (287) 19 20 21 22 23 24 25 26 48 49 50 52 53 54 55
    56 57
RETURN (288) 44 45
IF (289) 46 47 48 49
ELSE (290) 46 48
FOR (291) 52 53 54 55
DO (292) 56
WHILE (293) 56 57
NUM (294) 77
FLOAT (295) 76
ID (296) 7 8 9 10 11 12 13 14 17 18 27 28 29 30 31 32 33 34 52 53 54
    55 59 61 68 69


Nonterminals, with rules where they appear

$accept (42)
    on left: 0
program (43)
    on left: 1, on right: 0
decls (44)
    on left: 2 3, on right: 1 3
decl (45)
    on left: 4 5 6, on right: 2 3
globdecl (46)
    on left: 7 8, on right: 6
globdef (47)
    on left: 9, on right: 5
fundef (48)
    on left: 10, on right: 4 15 16
param (49)
    on left: 11 12 13 14, on right: 10 11 13
fundefs (50)
    on left: 15 16, on right: 15 19 20 22 25
ids (51)
    on left: 17 18, on right: 7 11 12 17
funbody (52)
    on left: 19 20 21 22 23 24 25 26, on right: 10
vardecl (53)
    on left: 27 28 29 30 31 32 33 34, on right: 19 21 22 23 27 29 30
    33
stmts (54)
    on left: 35 36, on right: 19 20 21 24 35 50 54 55 56 57
stmt (55)
    on left: 37 38 39 40 41 42 43, on right: 35 36
return (56)
    on left: 44 45, on right: 38
ifelse (57)
    on left: 46 47 48 49, on right: 39
block (58)
    on left: 50, on right: 46 47
assign (59)
    on left: 51, on right: 37
for (60)
    on left: 52 53 54 55, on right: 40
dowhile (61)
    on left: 56, on right: 41
while (62)
    on left: 57, on right: 42
exprstmt (63)
    on left: 58, on right: 43
varlet (64)
    on left: 59, on right: 51
expr (65)
    on left: 60 61 62 63 64 65 66, on right: 9 27 28 30 32 44 46 47
    48 49 51 52 53 54 55 56 57 58 62 63 67 71 72
cast (66)
    on left: 67, on right: 64
funcall (67)
    on left: 68 69, on right: 65
arrexpr (68)
    on left: 70, on right: 66
exprs (69)
    on left: 71 72, on right: 27 28 29 31 68 70 72
constant (70)
    on left: 73 74 75, on right: 60
floatval (71)
    on left: 76, on right: 73
intval (72)
    on left: 77, on right: 74
boolval (73)
    on left: 78 79, on right: 75
binop (74)
    on left: 80 81 82 83 84 85 86 87 88 89 90 91, on right: 63
monop (75)
    on left: 92 93, on right: 62
type (76)
    on left: 94 95 96, on right: 7 8 9 10 11 12 13 14 27 28 29 30 31
    32 33 34 52 53 54 55 67


state 0

    0 $accept: . program $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    program   go to state 4
    decls     go to state 5
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 1

   94 type: INT_TYPE .

    $default  reduce using rule 94 (type)


state 2

   95 type: FLOAT_TYPE .

    $default  reduce using rule 95 (type)


state 3

   96 type: BOOL_TYPE .

    $default  reduce using rule 96 (type)


state 4

    0 $accept: program . $end

    $end  shift, and go to state 11


state 5

    1 program: decls .

    $default  reduce using rule 1 (program)


state 6

    2 decls: decl .
    3      | decl . decls

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 2 (decls)

    decls     go to state 12
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 7

    6 decl: globdecl .

    $default  reduce using rule 6 (decl)


state 8

    5 decl: globdef .

    $default  reduce using rule 5 (decl)


state 9

    4 decl: fundef .

    $default  reduce using rule 4 (decl)


state 10

    7 globdecl: type . ID ids SEMICOLON
    8         | type . ID SEMICOLON
    9 globdef: type . ID LET expr SEMICOLON
   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 13


state 11

    0 $accept: program $end .

    $default  accept


state 12

    3 decls: decl decls .

    $default  reduce using rule 3 (decls)


state 13

    7 globdecl: type ID . ids SEMICOLON
    8         | type ID . SEMICOLON
    9 globdef: type ID . LET expr SEMICOLON
   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 15
    LET        shift, and go to state 16
    ID         shift, and go to state 17

    ids  go to state 18


state 14

   10 fundef: type ID BRACKET_L . param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 19
    type   go to state 20


state 15

    8 globdecl: type ID SEMICOLON .

    $default  reduce using rule 8 (globdecl)


state 16

    9 globdef: type ID LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 29
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 17

   17 ids: ID . ids
   18    | ID .

    ID  shift, and go to state 17

    $default  reduce using rule 18 (ids)

    ids  go to state 39


state 18

    7 globdecl: type ID ids . SEMICOLON

    SEMICOLON  shift, and go to state 40


state 19

   10 fundef: type ID BRACKET_L param . BRACKET_R funbody

    BRACKET_R  shift, and go to state 41


state 20

   11 param: type . ID ids param
   12      | type . ID ids
   13      | type . ID COMMA param
   14      | type . ID

    ID  shift, and go to state 42


state 21

   63 expr: BRACKET_L . expr binop expr BRACKET_R
   67 cast: BRACKET_L . type BRACKET_R expr SEMICOLON

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    BRACKET_L   shift, and go to state 21
    MINUS       shift, and go to state 22
    NOT         shift, and go to state 23
    TRUEVAL     shift, and go to state 24
    FALSEVAL    shift, and go to state 25
    NUM         shift, and go to state 26
    FLOAT       shift, and go to state 27
    ID          shift, and go to state 28

    expr      go to state 43
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38
    type      go to state 44


state 22

   93 monop: MINUS .

    $default  reduce using rule 93 (monop)


state 23

   92 monop: NOT .

    $default  reduce using rule 92 (monop)


state 24

   78 boolval: TRUEVAL .

    $default  reduce using rule 78 (boolval)


state 25

   79 boolval: FALSEVAL .

    $default  reduce using rule 79 (boolval)


state 26

   77 intval: NUM .

    $default  reduce using rule 77 (intval)


state 27

   76 floatval: FLOAT .

    $default  reduce using rule 76 (floatval)


state 28

   61 expr: ID .
   68 funcall: ID . BRACKET_L exprs BRACKET_R SEMICOLON
   69        | ID . BRACKET_L BRACKET_R

    BRACKET_L  shift, and go to state 45

    BRACKET_L  [reduce using rule 61 (expr)]
    $default   reduce using rule 61 (expr)


state 29

    9 globdef: type ID LET expr . SEMICOLON
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA      shift, and go to state 46
    SEMICOLON  shift, and go to state 47

    COMMA      [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]


state 30

   64 expr: cast .

    $default  reduce using rule 64 (expr)


state 31

   65 expr: funcall .

    $default  reduce using rule 65 (expr)


state 32

   66 expr: arrexpr .

    $default  reduce using rule 66 (expr)


state 33

   70 arrexpr: exprs .

    $default  reduce using rule 70 (arrexpr)


state 34

   60 expr: constant .

    $default  reduce using rule 60 (expr)


state 35

   73 constant: floatval .

    $default  reduce using rule 73 (constant)


state 36

   74 constant: intval .

    $default  reduce using rule 74 (constant)


state 37

   75 constant: boolval .

    $default  reduce using rule 75 (constant)


state 38

   62 expr: monop . expr

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 48
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 39

   17 ids: ID ids .

    $default  reduce using rule 17 (ids)


state 40

    7 globdecl: type ID ids SEMICOLON .

    $default  reduce using rule 7 (globdecl)


state 41

   10 fundef: type ID BRACKET_L param BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 49

    funbody  go to state 50


state 42

   11 param: type ID . ids param
   12      | type ID . ids
   13      | type ID . COMMA param
   14      | type ID .

    COMMA  shift, and go to state 51
    ID     shift, and go to state 17

    $default  reduce using rule 14 (param)

    ids  go to state 52


state 43

   63 expr: BRACKET_L expr . binop expr BRACKET_R
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA    shift, and go to state 46
    MINUS    shift, and go to state 53
    PLUS     shift, and go to state 54
    STAR     shift, and go to state 55
    SLASH    shift, and go to state 56
    PERCENT  shift, and go to state 57
    LE       shift, and go to state 58
    LT       shift, and go to state 59
    GE       shift, and go to state 60
    GT       shift, and go to state 61
    EQ       shift, and go to state 62
    OR       shift, and go to state 63
    AND      shift, and go to state 64

    COMMA    [reduce using rule 71 (exprs)]
    MINUS    [reduce using rule 71 (exprs)]
    PLUS     [reduce using rule 71 (exprs)]
    STAR     [reduce using rule 71 (exprs)]
    SLASH    [reduce using rule 71 (exprs)]
    PERCENT  [reduce using rule 71 (exprs)]
    LE       [reduce using rule 71 (exprs)]
    LT       [reduce using rule 71 (exprs)]
    GE       [reduce using rule 71 (exprs)]
    GT       [reduce using rule 71 (exprs)]
    EQ       [reduce using rule 71 (exprs)]
    OR       [reduce using rule 71 (exprs)]
    AND      [reduce using rule 71 (exprs)]

    binop  go to state 65


state 44

   67 cast: BRACKET_L type . BRACKET_R expr SEMICOLON

    BRACKET_R  shift, and go to state 66


state 45

   68 funcall: ID BRACKET_L . exprs BRACKET_R SEMICOLON
   69        | ID BRACKET_L . BRACKET_R

    BRACKET_L  shift, and go to state 21
    BRACKET_R  shift, and go to state 67
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 68
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 69
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 46

   72 exprs: expr COMMA . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 68
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 70
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 47

    9 globdef: type ID LET expr SEMICOLON .

    $default  reduce using rule 9 (globdef)


state 48

   62 expr: monop expr .
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA  shift, and go to state 46

    BRACKET_L        reduce using rule 62 (expr)
    BRACKET_L        [reduce using rule 71 (exprs)]
    BRACKET_R        reduce using rule 62 (expr)
    BRACKET_R        [reduce using rule 71 (exprs)]
    COMMA            [reduce using rule 62 (expr)]
    COMMA            [reduce using rule 71 (exprs)]
    SEMICOLON        reduce using rule 62 (expr)
    SEMICOLON        [reduce using rule 71 (exprs)]
    MINUS            reduce using rule 62 (expr)
    MINUS            [reduce using rule 71 (exprs)]
    PLUS             reduce using rule 62 (expr)
    PLUS             [reduce using rule 71 (exprs)]
    STAR             reduce using rule 62 (expr)
    STAR             [reduce using rule 71 (exprs)]
    SLASH            reduce using rule 62 (expr)
    SLASH            [reduce using rule 71 (exprs)]
    PERCENT          reduce using rule 62 (expr)
    PERCENT          [reduce using rule 71 (exprs)]
    LE               reduce using rule 62 (expr)
    LE               [reduce using rule 71 (exprs)]
    LT               reduce using rule 62 (expr)
    LT               [reduce using rule 71 (exprs)]
    GE               reduce using rule 62 (expr)
    GE               [reduce using rule 71 (exprs)]
    GT               reduce using rule 62 (expr)
    GT               [reduce using rule 71 (exprs)]
    EQ               reduce using rule 62 (expr)
    EQ               [reduce using rule 71 (exprs)]
    OR               reduce using rule 62 (expr)
    OR               [reduce using rule 71 (exprs)]
    AND              reduce using rule 62 (expr)
    AND              [reduce using rule 71 (exprs)]
    NOT              reduce using rule 62 (expr)
    NOT              [reduce using rule 71 (exprs)]
    TRUEVAL          reduce using rule 62 (expr)
    TRUEVAL          [reduce using rule 71 (exprs)]
    FALSEVAL         reduce using rule 62 (expr)
    FALSEVAL         [reduce using rule 71 (exprs)]
    CURLY_BRACKET_R  reduce using rule 62 (expr)
    CURLY_BRACKET_R  [reduce using rule 71 (exprs)]
    RETURN           reduce using rule 62 (expr)
    RETURN           [reduce using rule 71 (exprs)]
    IF               reduce using rule 62 (expr)
    IF               [reduce using rule 71 (exprs)]
    FOR              reduce using rule 62 (expr)
    FOR              [reduce using rule 71 (exprs)]
    DO               reduce using rule 62 (expr)
    DO               [reduce using rule 71 (exprs)]
    WHILE            reduce using rule 62 (expr)
    WHILE            [reduce using rule 71 (exprs)]
    NUM              reduce using rule 62 (expr)
    NUM              [reduce using rule 71 (exprs)]
    FLOAT            reduce using rule 62 (expr)
    FLOAT            [reduce using rule 71 (exprs)]
    ID               reduce using rule 62 (expr)
    ID               [reduce using rule 71 (exprs)]
    $default         reduce using rule 62 (expr)


state 49

   19 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 71
    RETURN           shift, and go to state 72
    IF               shift, and go to state 73
    FOR              shift, and go to state 74
    DO               shift, and go to state 75
    WHILE            shift, and go to state 76
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 77

    fundef    go to state 78
    fundefs   go to state 79
    vardecl   go to state 80
    stmts     go to state 81
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38
    type      go to state 92


state 50

   10 fundef: type ID BRACKET_L param BRACKET_R funbody .

    $default  reduce using rule 10 (fundef)


state 51

   13 param: type ID COMMA . param

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 93
    type   go to state 20


state 52

   11 param: type ID ids . param
   12      | type ID ids .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 12 (param)

    param  go to state 94
    type   go to state 20


state 53

   81 binop: MINUS .

    $default  reduce using rule 81 (binop)


state 54

   80 binop: PLUS .

    $default  reduce using rule 80 (binop)


state 55

   82 binop: STAR .

    $default  reduce using rule 82 (binop)


state 56

   83 binop: SLASH .

    $default  reduce using rule 83 (binop)


state 57

   84 binop: PERCENT .

    $default  reduce using rule 84 (binop)


state 58

   85 binop: LE .

    $default  reduce using rule 85 (binop)


state 59

   86 binop: LT .

    $default  reduce using rule 86 (binop)


state 60

   87 binop: GE .

    $default  reduce using rule 87 (binop)


state 61

   88 binop: GT .

    $default  reduce using rule 88 (binop)


state 62

   89 binop: EQ .

    $default  reduce using rule 89 (binop)


state 63

   90 binop: OR .

    $default  reduce using rule 90 (binop)


state 64

   91 binop: AND .

    $default  reduce using rule 91 (binop)


state 65

   63 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 95
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 66

   67 cast: BRACKET_L type BRACKET_R . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 96
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 67

   69 funcall: ID BRACKET_L BRACKET_R .

    $default  reduce using rule 69 (funcall)


state 68

   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA  shift, and go to state 46

    COMMA     [reduce using rule 71 (exprs)]
    $default  reduce using rule 71 (exprs)


state 69

   68 funcall: ID BRACKET_L exprs . BRACKET_R SEMICOLON
   70 arrexpr: exprs .

    BRACKET_R  shift, and go to state 97

    BRACKET_R  [reduce using rule 70 (arrexpr)]
    $default   reduce using rule 70 (arrexpr)


state 70

   70 arrexpr: exprs .
   72 exprs: expr COMMA exprs .

    BRACKET_L        reduce using rule 70 (arrexpr)
    BRACKET_L        [reduce using rule 72 (exprs)]
    BRACKET_R        reduce using rule 70 (arrexpr)
    BRACKET_R        [reduce using rule 72 (exprs)]
    COMMA            reduce using rule 70 (arrexpr)
    COMMA            [reduce using rule 72 (exprs)]
    SEMICOLON        reduce using rule 70 (arrexpr)
    SEMICOLON        [reduce using rule 72 (exprs)]
    MINUS            reduce using rule 70 (arrexpr)
    MINUS            [reduce using rule 72 (exprs)]
    PLUS             reduce using rule 70 (arrexpr)
    PLUS             [reduce using rule 72 (exprs)]
    STAR             reduce using rule 70 (arrexpr)
    STAR             [reduce using rule 72 (exprs)]
    SLASH            reduce using rule 70 (arrexpr)
    SLASH            [reduce using rule 72 (exprs)]
    PERCENT          reduce using rule 70 (arrexpr)
    PERCENT          [reduce using rule 72 (exprs)]
    LE               reduce using rule 70 (arrexpr)
    LE               [reduce using rule 72 (exprs)]
    LT               reduce using rule 70 (arrexpr)
    LT               [reduce using rule 72 (exprs)]
    GE               reduce using rule 70 (arrexpr)
    GE               [reduce using rule 72 (exprs)]
    GT               reduce using rule 70 (arrexpr)
    GT               [reduce using rule 72 (exprs)]
    EQ               reduce using rule 70 (arrexpr)
    EQ               [reduce using rule 72 (exprs)]
    OR               reduce using rule 70 (arrexpr)
    OR               [reduce using rule 72 (exprs)]
    AND              reduce using rule 70 (arrexpr)
    AND              [reduce using rule 72 (exprs)]
    NOT              reduce using rule 70 (arrexpr)
    NOT              [reduce using rule 72 (exprs)]
    TRUEVAL          reduce using rule 70 (arrexpr)
    TRUEVAL          [reduce using rule 72 (exprs)]
    FALSEVAL         reduce using rule 70 (arrexpr)
    FALSEVAL         [reduce using rule 72 (exprs)]
    CURLY_BRACKET_R  reduce using rule 70 (arrexpr)
    CURLY_BRACKET_R  [reduce using rule 72 (exprs)]
    RETURN           reduce using rule 70 (arrexpr)
    RETURN           [reduce using rule 72 (exprs)]
    IF               reduce using rule 70 (arrexpr)
    IF               [reduce using rule 72 (exprs)]
    FOR              reduce using rule 70 (arrexpr)
    FOR              [reduce using rule 72 (exprs)]
    DO               reduce using rule 70 (arrexpr)
    DO               [reduce using rule 72 (exprs)]
    WHILE            reduce using rule 70 (arrexpr)
    WHILE            [reduce using rule 72 (exprs)]
    NUM              reduce using rule 70 (arrexpr)
    NUM              [reduce using rule 72 (exprs)]
    FLOAT            reduce using rule 70 (arrexpr)
    FLOAT            [reduce using rule 72 (exprs)]
    ID               reduce using rule 70 (arrexpr)
    ID               [reduce using rule 72 (exprs)]
    $default         reduce using rule 70 (arrexpr)


state 71

   26 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 26 (funbody)


state 72

   44 return: RETURN . expr SEMICOLON
   45       | RETURN . SEMICOLON

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 98
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 99
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 73

   46 ifelse: IF . BRACKET_L expr BRACKET_R block ELSE block
   47       | IF . BRACKET_L expr BRACKET_R block
   48       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 100


state 74

   52 for: FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 101


state 75

   56 dowhile: DO . CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_L  shift, and go to state 102


state 76

   57 while: WHILE . BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 103


state 77

   59 varlet: ID .
   61 expr: ID .
   68 funcall: ID . BRACKET_L exprs BRACKET_R SEMICOLON
   69        | ID . BRACKET_L BRACKET_R

    BRACKET_L  shift, and go to state 45

    BRACKET_L  [reduce using rule 61 (expr)]
    LET        reduce using rule 59 (varlet)
    $default   reduce using rule 61 (expr)


state 78

   15 fundefs: fundef . fundefs
   16        | fundef .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 16 (fundefs)

    fundef   go to state 78
    fundefs  go to state 104
    type     go to state 105


state 79

   20 funbody: CURLY_BRACKET_L fundefs . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs . CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 106
    RETURN           shift, and go to state 72
    IF               shift, and go to state 73
    FOR              shift, and go to state 74
    DO               shift, and go to state 75
    WHILE            shift, and go to state 76
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 77

    stmts     go to state 107
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 80

   19 funbody: CURLY_BRACKET_L vardecl . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl . fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 108
    RETURN           shift, and go to state 72
    IF               shift, and go to state 73
    FOR              shift, and go to state 74
    DO               shift, and go to state 75
    WHILE            shift, and go to state 76
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 77

    fundef    go to state 78
    fundefs   go to state 109
    stmts     go to state 110
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38
    type      go to state 105


state 81

   24 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 111


state 82

   35 stmts: stmt . stmts
   36      | stmt .

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 72
    IF         shift, and go to state 73
    FOR        shift, and go to state 74
    DO         shift, and go to state 75
    WHILE      shift, and go to state 76
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 77

    $default  reduce using rule 36 (stmts)

    stmts     go to state 112
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 83

   38 stmt: return .

    $default  reduce using rule 38 (stmt)


state 84

   39 stmt: ifelse .

    $default  reduce using rule 39 (stmt)


state 85

   37 stmt: assign .

    $default  reduce using rule 37 (stmt)


state 86

   40 stmt: for .

    $default  reduce using rule 40 (stmt)


state 87

   41 stmt: dowhile .

    $default  reduce using rule 41 (stmt)


state 88

   42 stmt: while .

    $default  reduce using rule 42 (stmt)


state 89

   43 stmt: exprstmt .

    $default  reduce using rule 43 (stmt)


state 90

   51 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 113


state 91

   58 exprstmt: expr .
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA  shift, and go to state 46

    BRACKET_L        reduce using rule 58 (exprstmt)
    BRACKET_L        [reduce using rule 71 (exprs)]
    COMMA            [reduce using rule 71 (exprs)]
    MINUS            reduce using rule 58 (exprstmt)
    MINUS            [reduce using rule 71 (exprs)]
    NOT              reduce using rule 58 (exprstmt)
    NOT              [reduce using rule 71 (exprs)]
    TRUEVAL          reduce using rule 58 (exprstmt)
    TRUEVAL          [reduce using rule 71 (exprs)]
    FALSEVAL         reduce using rule 58 (exprstmt)
    FALSEVAL         [reduce using rule 71 (exprs)]
    CURLY_BRACKET_R  reduce using rule 58 (exprstmt)
    CURLY_BRACKET_R  [reduce using rule 71 (exprs)]
    RETURN           reduce using rule 58 (exprstmt)
    RETURN           [reduce using rule 71 (exprs)]
    IF               reduce using rule 58 (exprstmt)
    IF               [reduce using rule 71 (exprs)]
    FOR              reduce using rule 58 (exprstmt)
    FOR              [reduce using rule 71 (exprs)]
    DO               reduce using rule 58 (exprstmt)
    DO               [reduce using rule 71 (exprs)]
    WHILE            reduce using rule 58 (exprstmt)
    WHILE            [reduce using rule 71 (exprs)]
    NUM              reduce using rule 58 (exprstmt)
    NUM              [reduce using rule 71 (exprs)]
    FLOAT            reduce using rule 58 (exprstmt)
    FLOAT            [reduce using rule 71 (exprs)]
    ID               reduce using rule 58 (exprstmt)
    ID               [reduce using rule 71 (exprs)]
    $default         reduce using rule 58 (exprstmt)


state 92

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody
   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 114


state 93

   13 param: type ID COMMA param .

    $default  reduce using rule 13 (param)


state 94

   11 param: type ID ids param .

    $default  reduce using rule 11 (param)


state 95

   63 expr: BRACKET_L expr binop expr . BRACKET_R
   71 exprs: expr .
   72      | expr . COMMA exprs

    BRACKET_R  shift, and go to state 115
    COMMA      shift, and go to state 46

    BRACKET_R  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]


state 96

   67 cast: BRACKET_L type BRACKET_R expr . SEMICOLON
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA      shift, and go to state 46
    SEMICOLON  shift, and go to state 116

    COMMA      [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]


state 97

   68 funcall: ID BRACKET_L exprs BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 117


state 98

   45 return: RETURN SEMICOLON .

    $default  reduce using rule 45 (return)


state 99

   44 return: RETURN expr . SEMICOLON
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA      shift, and go to state 46
    SEMICOLON  shift, and go to state 118

    COMMA      [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]


state 100

   46 ifelse: IF BRACKET_L . expr BRACKET_R block ELSE block
   47       | IF BRACKET_L . expr BRACKET_R block
   48       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 119
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 101

   52 for: FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 120


state 102

   56 dowhile: DO CURLY_BRACKET_L . stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 72
    IF         shift, and go to state 73
    FOR        shift, and go to state 74
    DO         shift, and go to state 75
    WHILE      shift, and go to state 76
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 77

    stmts     go to state 121
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 103

   57 while: WHILE BRACKET_L . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 122
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 104

   15 fundefs: fundef fundefs .

    $default  reduce using rule 15 (fundefs)


state 105

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 123


state 106

   25 funbody: CURLY_BRACKET_L fundefs CURLY_BRACKET_R .

    $default  reduce using rule 25 (funbody)


state 107

   20 funbody: CURLY_BRACKET_L fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 124


state 108

   23 funbody: CURLY_BRACKET_L vardecl CURLY_BRACKET_R .

    $default  reduce using rule 23 (funbody)


state 109

   19 funbody: CURLY_BRACKET_L vardecl fundefs . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs . CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 125
    RETURN           shift, and go to state 72
    IF               shift, and go to state 73
    FOR              shift, and go to state 74
    DO               shift, and go to state 75
    WHILE            shift, and go to state 76
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 77

    stmts     go to state 126
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 110

   21 funbody: CURLY_BRACKET_L vardecl stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 127


state 111

   24 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 24 (funbody)


state 112

   35 stmts: stmt stmts .

    $default  reduce using rule 35 (stmts)


state 113

   51 assign: varlet LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 128
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 114

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody
   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 129
    LET        shift, and go to state 130


state 115

   63 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 63 (expr)


state 116

   67 cast: BRACKET_L type BRACKET_R expr SEMICOLON .

    $default  reduce using rule 67 (cast)


state 117

   68 funcall: ID BRACKET_L exprs BRACKET_R SEMICOLON .

    $default  reduce using rule 68 (funcall)


state 118

   44 return: RETURN expr SEMICOLON .

    $default  reduce using rule 44 (return)


state 119

   46 ifelse: IF BRACKET_L expr . BRACKET_R block ELSE block
   47       | IF BRACKET_L expr . BRACKET_R block
   48       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . COMMA exprs

    BRACKET_R  shift, and go to state 131
    COMMA      shift, and go to state 46

    BRACKET_R  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]


state 120

   52 for: FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    ID  shift, and go to state 132


state 121

   56 dowhile: DO CURLY_BRACKET_L stmts . CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_R  shift, and go to state 133


state 122

   57 while: WHILE BRACKET_L expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . COMMA exprs

    BRACKET_R  shift, and go to state 134
    COMMA      shift, and go to state 46

    BRACKET_R  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]


state 123

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14


state 124

   20 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 20 (funbody)


state 125

   22 funbody: CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R .

    $default  reduce using rule 22 (funbody)


state 126

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 135


state 127

   21 funbody: CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R .

    $default  reduce using rule 21 (funbody)


state 128

   51 assign: varlet LET expr . SEMICOLON
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA      shift, and go to state 46
    SEMICOLON  shift, and go to state 136

    COMMA      [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]


state 129

   34 vardecl: type ID SEMICOLON .

    $default  reduce using rule 34 (vardecl)


state 130

   27 vardecl: type ID LET . exprs expr SEMICOLON vardecl
   28        | type ID LET . exprs expr SEMICOLON
   29        | type ID LET . exprs SEMICOLON vardecl
   30        | type ID LET . expr SEMICOLON vardecl
   31        | type ID LET . exprs SEMICOLON
   32        | type ID LET . expr SEMICOLON
   33        | type ID LET . SEMICOLON vardecl

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 137
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 138
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 139
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 131

   46 ifelse: IF BRACKET_L expr BRACKET_R . block ELSE block
   47       | IF BRACKET_L expr BRACKET_R . block
   48       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 140

    block  go to state 141


state 132

   52 for: FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    LET  shift, and go to state 142


state 133

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R . WHILE BRACKET_L expr BRACKET_R SEMICOLON

    WHILE  shift, and go to state 143


state 134

   57 while: WHILE BRACKET_L expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 144


state 135

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 19 (funbody)


state 136

   51 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 51 (assign)


state 137

   33 vardecl: type ID LET SEMICOLON . vardecl

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    vardecl  go to state 145
    type     go to state 146


state 138

   30 vardecl: type ID LET expr . SEMICOLON vardecl
   32        | type ID LET expr . SEMICOLON
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA      shift, and go to state 46
    SEMICOLON  shift, and go to state 147

    COMMA      [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]
    $default   reduce using rule 71 (exprs)


state 139

   27 vardecl: type ID LET exprs . expr SEMICOLON vardecl
   28        | type ID LET exprs . expr SEMICOLON
   29        | type ID LET exprs . SEMICOLON vardecl
   31        | type ID LET exprs . SEMICOLON
   70 arrexpr: exprs .

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 148
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    BRACKET_L  [reduce using rule 70 (arrexpr)]
    SEMICOLON  [reduce using rule 70 (arrexpr)]
    MINUS      [reduce using rule 70 (arrexpr)]
    NOT        [reduce using rule 70 (arrexpr)]
    TRUEVAL    [reduce using rule 70 (arrexpr)]
    FALSEVAL   [reduce using rule 70 (arrexpr)]
    NUM        [reduce using rule 70 (arrexpr)]
    FLOAT      [reduce using rule 70 (arrexpr)]
    ID         [reduce using rule 70 (arrexpr)]
    $default   reduce using rule 70 (arrexpr)

    expr      go to state 149
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 140

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   50 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 150
    RETURN           shift, and go to state 72
    IF               shift, and go to state 73
    FOR              shift, and go to state 74
    DO               shift, and go to state 75
    WHILE            shift, and go to state 76
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 77

    stmts     go to state 151
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 141

   46 ifelse: IF BRACKET_L expr BRACKET_R block . ELSE block
   47       | IF BRACKET_L expr BRACKET_R block .

    ELSE  shift, and go to state 152

    $default  reduce using rule 47 (ifelse)


state 142

   52 for: FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 153
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 143

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE . BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 154


state 144

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 72
    IF         shift, and go to state 73
    FOR        shift, and go to state 74
    DO         shift, and go to state 75
    WHILE      shift, and go to state 76
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 77

    stmts     go to state 155
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 145

   33 vardecl: type ID LET SEMICOLON vardecl .

    $default  reduce using rule 33 (vardecl)


state 146

   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 156


state 147

   30 vardecl: type ID LET expr SEMICOLON . vardecl
   32        | type ID LET expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 32 (vardecl)]
    FLOAT_TYPE  [reduce using rule 32 (vardecl)]
    BOOL_TYPE   [reduce using rule 32 (vardecl)]
    $default    reduce using rule 32 (vardecl)

    vardecl  go to state 157
    type     go to state 146


state 148

   29 vardecl: type ID LET exprs SEMICOLON . vardecl
   31        | type ID LET exprs SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 31 (vardecl)]
    FLOAT_TYPE  [reduce using rule 31 (vardecl)]
    BOOL_TYPE   [reduce using rule 31 (vardecl)]
    $default    reduce using rule 31 (vardecl)

    vardecl  go to state 158
    type     go to state 146


state 149

   27 vardecl: type ID LET exprs expr . SEMICOLON vardecl
   28        | type ID LET exprs expr . SEMICOLON
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA      shift, and go to state 46
    SEMICOLON  shift, and go to state 159

    COMMA      [reduce using rule 71 (exprs)]
    SEMICOLON  [reduce using rule 71 (exprs)]


state 150

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   49       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    ELSE  shift, and go to state 160

    $default  reduce using rule 49 (ifelse)


state 151

   50 block: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 161


state 152

   46 ifelse: IF BRACKET_L expr BRACKET_R block ELSE . block

    CURLY_BRACKET_L  shift, and go to state 162

    block  go to state 163


state 153

   52 for: FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . COMMA exprs

    COMMA  shift, and go to state 164

    COMMA  [reduce using rule 71 (exprs)]


state 154

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L . expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 165
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 155

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 166


state 156

   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    SEMICOLON  shift, and go to state 129
    LET        shift, and go to state 130


state 157

   30 vardecl: type ID LET expr SEMICOLON vardecl .

    $default  reduce using rule 30 (vardecl)


state 158

   29 vardecl: type ID LET exprs SEMICOLON vardecl .

    $default  reduce using rule 29 (vardecl)


state 159

   27 vardecl: type ID LET exprs expr SEMICOLON . vardecl
   28        | type ID LET exprs expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 28 (vardecl)]
    FLOAT_TYPE  [reduce using rule 28 (vardecl)]
    BOOL_TYPE   [reduce using rule 28 (vardecl)]
    $default    reduce using rule 28 (vardecl)

    vardecl  go to state 167
    type     go to state 146


state 160

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 168


state 161

   50 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 50 (block)


state 162

   50 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    RETURN     shift, and go to state 72
    IF         shift, and go to state 73
    FOR        shift, and go to state 74
    DO         shift, and go to state 75
    WHILE      shift, and go to state 76
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 77

    stmts     go to state 151
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 163

   46 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block .

    $default  reduce using rule 46 (ifelse)


state 164

   52 for: FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   72 exprs: expr COMMA . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 169
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 70
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 165

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr . BRACKET_R SEMICOLON
   71 exprs: expr .
   72      | expr . COMMA exprs

    BRACKET_R  shift, and go to state 170
    COMMA      shift, and go to state 46

    BRACKET_R  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]


state 166

   57 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 57 (while)


state 167

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl .

    $default  reduce using rule 27 (vardecl)


state 168

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 171


state 169

   52 for: FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . COMMA exprs

    BRACKET_R  shift, and go to state 172
    COMMA      shift, and go to state 173

    BRACKET_R  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]


state 170

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 174


state 171

   48 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 48 (ifelse)


state 172

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 175


state 173

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   72 exprs: expr COMMA . exprs

    BRACKET_L  shift, and go to state 21
    MINUS      shift, and go to state 22
    NOT        shift, and go to state 23
    TRUEVAL    shift, and go to state 24
    FALSEVAL   shift, and go to state 25
    NUM        shift, and go to state 26
    FLOAT      shift, and go to state 27
    ID         shift, and go to state 28

    expr      go to state 176
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 70
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 174

   56 dowhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON .

    $default  reduce using rule 56 (dowhile)


state 175

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 177
    RETURN           shift, and go to state 72
    IF               shift, and go to state 73
    FOR              shift, and go to state 74
    DO               shift, and go to state 75
    WHILE            shift, and go to state 76
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 77

    stmts     go to state 178
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 176

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   71 exprs: expr .
   72      | expr . COMMA exprs

    BRACKET_R  shift, and go to state 179
    COMMA      shift, and go to state 46

    BRACKET_R  [reduce using rule 71 (exprs)]
    COMMA      [reduce using rule 71 (exprs)]


state 177

   52 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 52 (for)


state 178

   54 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 180


state 179

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 181


state 180

   54 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 54 (for)


state 181

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   55    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    BRACKET_L        shift, and go to state 21
    MINUS            shift, and go to state 22
    NOT              shift, and go to state 23
    TRUEVAL          shift, and go to state 24
    FALSEVAL         shift, and go to state 25
    CURLY_BRACKET_R  shift, and go to state 182
    RETURN           shift, and go to state 72
    IF               shift, and go to state 73
    FOR              shift, and go to state 74
    DO               shift, and go to state 75
    WHILE            shift, and go to state 76
    NUM              shift, and go to state 26
    FLOAT            shift, and go to state 27
    ID               shift, and go to state 77

    stmts     go to state 183
    stmt      go to state 82
    return    go to state 83
    ifelse    go to state 84
    assign    go to state 85
    for       go to state 86
    dowhile   go to state 87
    while     go to state 88
    exprstmt  go to state 89
    varlet    go to state 90
    expr      go to state 91
    cast      go to state 30
    funcall   go to state 31
    arrexpr   go to state 32
    exprs     go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37
    monop     go to state 38


state 182

   53 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 53 (for)


state 183

   55 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 184


state 184

   55 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 55 (for)
