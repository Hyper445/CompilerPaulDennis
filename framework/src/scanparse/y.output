Terminals which are not used

   NE
   INTTYPE
   FLOATTYPE
   BOOLTYPE


State 116 conflicts: 7 shift/reduce
State 125 conflicts: 3 shift/reduce
State 126 conflicts: 6 shift/reduce
State 128 conflicts: 3 shift/reduce
State 139 conflicts: 3 shift/reduce


Grammar

    0 $accept: program $end

    1 program: decls

    2 decls: decl
    3      | decl decls

    4 decl: fundef
    5     | globdef
    6     | globdecl

    7 globdecl: type ID ids SEMICOLON
    8         | type ID SEMICOLON

    9 globdef: type ID LET expr SEMICOLON

   10 fundef: type ID BRACKET_L param BRACKET_R funbody

   11 param: type ID ids param
   12      | type ID ids
   13      | type ID COMMA param
   14      | type ID

   15 fundefs: fundef fundefs
   16        | fundef

   17 ids: ID ids
   18    | ID

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L CURLY_BRACKET_R

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl
   28        | type ID LET exprs expr SEMICOLON
   29        | type ID LET exprs SEMICOLON vardecl
   30        | type ID LET expr SEMICOLON vardecl
   31        | type ID LET exprs SEMICOLON
   32        | type ID LET expr SEMICOLON
   33        | type ID LET SEMICOLON vardecl
   34        | type ID SEMICOLON

   35 stmts: stmt stmts
   36      | stmt

   37 stmt: assign
   38     | return
   39     | ifelse
   40     | for
   41     | doWhile
   42     | while

   43 return: RETURN expr SEMICOLON
   44       | RETURN SEMICOLON

   45 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block
   46       | IF BRACKET_L expr BRACKET_R block
   47       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

   49 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R

   50 assign: varlet LET expr SEMICOLON

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

   57 varlet: ID

   58 expr: constant
   59     | ID
   60     | BRACKET_L expr binop expr BRACKET_R

   61 exprs: expr
   62      | expr exprs

   63 constant: floatval
   64         | intval
   65         | boolval

   66 floatval: FLOAT

   67 intval: NUM

   68 boolval: TRUEVAL
   69        | FALSEVAL

   70 binop: PLUS
   71      | MINUS
   72      | STAR
   73      | SLASH
   74      | PERCENT
   75      | LE
   76      | LT
   77      | GE
   78      | GT
   79      | EQ
   80      | OR
   81      | AND

   82 type: INT_TYPE
   83     | FLOAT_TYPE
   84     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 82
FLOAT_TYPE (259) 83
BOOL_TYPE (260) 84
BRACKET_L (261) 10 45 46 47 48 51 52 53 54 55 56 60
BRACKET_R (262) 10 45 46 47 48 51 52 53 54 55 56 60
COMMA (263) 13 51 52 53 54
SEMICOLON (264) 7 8 9 27 28 29 30 31 32 33 34 43 44 50 55
MINUS (265) 71
PLUS (266) 70
STAR (267) 72
SLASH (268) 73
PERCENT (269) 74
LE (270) 75
LT (271) 76
GE (272) 77
GT (273) 78
EQ (274) 79
NE (275)
OR (276) 80
AND (277) 81
TRUEVAL (278) 68
FALSEVAL (279) 69
LET (280) 9 27 28 29 30 31 32 33 50 51 52 53 54
INTTYPE (281)
FLOATTYPE (282)
BOOLTYPE (283)
CURLY_BRACKET_L (284) 19 20 21 22 23 24 25 26 47 48 49 51 52 53 54
    55 56
CURLY_BRACKET_R (285) 19 20 21 22 23 24 25 26 47 48 49 51 52 53 54
    55 56
RETURN (286) 43 44
IF (287) 45 46 47 48
ELSE (288) 45 47
FOR (289) 51 52 53 54
DO (290) 55
WHILE (291) 55 56
NUM (292) 67
FLOAT (293) 66
ID (294) 7 8 9 10 11 12 13 14 17 18 27 28 29 30 31 32 33 34 51 52 53
    54 57 59


Nonterminals, with rules where they appear

$accept (40)
    on left: 0
program (41)
    on left: 1, on right: 0
decls (42)
    on left: 2 3, on right: 1 3
decl (43)
    on left: 4 5 6, on right: 2 3
globdecl (44)
    on left: 7 8, on right: 6
globdef (45)
    on left: 9, on right: 5
fundef (46)
    on left: 10, on right: 4 15 16
param (47)
    on left: 11 12 13 14, on right: 10 11 13
fundefs (48)
    on left: 15 16, on right: 15 19 20 22 25
ids (49)
    on left: 17 18, on right: 7 11 12 17
funbody (50)
    on left: 19 20 21 22 23 24 25 26, on right: 10
vardecl (51)
    on left: 27 28 29 30 31 32 33 34, on right: 19 21 22 23 27 29 30
    33
stmts (52)
    on left: 35 36, on right: 19 20 21 24 35 49 53 54 55 56
stmt (53)
    on left: 37 38 39 40 41 42, on right: 35 36
return (54)
    on left: 43 44, on right: 38
ifelse (55)
    on left: 45 46 47 48, on right: 39
block (56)
    on left: 49, on right: 45 46
assign (57)
    on left: 50, on right: 37
for (58)
    on left: 51 52 53 54, on right: 40
doWhile (59)
    on left: 55, on right: 41
while (60)
    on left: 56, on right: 42
varlet (61)
    on left: 57, on right: 50
expr (62)
    on left: 58 59 60, on right: 9 27 28 30 32 43 45 46 47 48 50 51
    52 53 54 55 56 60 61 62
exprs (63)
    on left: 61 62, on right: 27 28 29 31 62
constant (64)
    on left: 63 64 65, on right: 58
floatval (65)
    on left: 66, on right: 63
intval (66)
    on left: 67, on right: 64
boolval (67)
    on left: 68 69, on right: 65
binop (68)
    on left: 70 71 72 73 74 75 76 77 78 79 80 81, on right: 60
type (69)
    on left: 82 83 84, on right: 7 8 9 10 11 12 13 14 27 28 29 30 31
    32 33 34 51 52 53 54


state 0

    0 $accept: . program $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    program   go to state 4
    decls     go to state 5
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 1

   82 type: INT_TYPE .

    $default  reduce using rule 82 (type)


state 2

   83 type: FLOAT_TYPE .

    $default  reduce using rule 83 (type)


state 3

   84 type: BOOL_TYPE .

    $default  reduce using rule 84 (type)


state 4

    0 $accept: program . $end

    $end  shift, and go to state 11


state 5

    1 program: decls .

    $default  reduce using rule 1 (program)


state 6

    2 decls: decl .
    3      | decl . decls

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 2 (decls)

    decls     go to state 12
    decl      go to state 6
    globdecl  go to state 7
    globdef   go to state 8
    fundef    go to state 9
    type      go to state 10


state 7

    6 decl: globdecl .

    $default  reduce using rule 6 (decl)


state 8

    5 decl: globdef .

    $default  reduce using rule 5 (decl)


state 9

    4 decl: fundef .

    $default  reduce using rule 4 (decl)


state 10

    7 globdecl: type . ID ids SEMICOLON
    8         | type . ID SEMICOLON
    9 globdef: type . ID LET expr SEMICOLON
   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 13


state 11

    0 $accept: program $end .

    $default  accept


state 12

    3 decls: decl decls .

    $default  reduce using rule 3 (decls)


state 13

    7 globdecl: type ID . ids SEMICOLON
    8         | type ID . SEMICOLON
    9 globdef: type ID . LET expr SEMICOLON
   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 15
    LET        shift, and go to state 16
    ID         shift, and go to state 17

    ids  go to state 18


state 14

   10 fundef: type ID BRACKET_L . param BRACKET_R funbody

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 19
    type   go to state 20


state 15

    8 globdecl: type ID SEMICOLON .

    $default  reduce using rule 8 (globdecl)


state 16

    9 globdef: type ID LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 27
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 17

   17 ids: ID . ids
   18    | ID .

    ID  shift, and go to state 17

    $default  reduce using rule 18 (ids)

    ids  go to state 32


state 18

    7 globdecl: type ID ids . SEMICOLON

    SEMICOLON  shift, and go to state 33


state 19

   10 fundef: type ID BRACKET_L param . BRACKET_R funbody

    BRACKET_R  shift, and go to state 34


state 20

   11 param: type . ID ids param
   12      | type . ID ids
   13      | type . ID COMMA param
   14      | type . ID

    ID  shift, and go to state 35


state 21

   60 expr: BRACKET_L . expr binop expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 36
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 22

   68 boolval: TRUEVAL .

    $default  reduce using rule 68 (boolval)


state 23

   69 boolval: FALSEVAL .

    $default  reduce using rule 69 (boolval)


state 24

   67 intval: NUM .

    $default  reduce using rule 67 (intval)


state 25

   66 floatval: FLOAT .

    $default  reduce using rule 66 (floatval)


state 26

   59 expr: ID .

    $default  reduce using rule 59 (expr)


state 27

    9 globdef: type ID LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 37


state 28

   58 expr: constant .

    $default  reduce using rule 58 (expr)


state 29

   63 constant: floatval .

    $default  reduce using rule 63 (constant)


state 30

   64 constant: intval .

    $default  reduce using rule 64 (constant)


state 31

   65 constant: boolval .

    $default  reduce using rule 65 (constant)


state 32

   17 ids: ID ids .

    $default  reduce using rule 17 (ids)


state 33

    7 globdecl: type ID ids SEMICOLON .

    $default  reduce using rule 7 (globdecl)


state 34

   10 fundef: type ID BRACKET_L param BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 38

    funbody  go to state 39


state 35

   11 param: type ID . ids param
   12      | type ID . ids
   13      | type ID . COMMA param
   14      | type ID .

    COMMA  shift, and go to state 40
    ID     shift, and go to state 17

    $default  reduce using rule 14 (param)

    ids  go to state 41


state 36

   60 expr: BRACKET_L expr . binop expr BRACKET_R

    MINUS    shift, and go to state 42
    PLUS     shift, and go to state 43
    STAR     shift, and go to state 44
    SLASH    shift, and go to state 45
    PERCENT  shift, and go to state 46
    LE       shift, and go to state 47
    LT       shift, and go to state 48
    GE       shift, and go to state 49
    GT       shift, and go to state 50
    EQ       shift, and go to state 51
    OR       shift, and go to state 52
    AND      shift, and go to state 53

    binop  go to state 54


state 37

    9 globdef: type ID LET expr SEMICOLON .

    $default  reduce using rule 9 (globdef)


state 38

   19 funbody: CURLY_BRACKET_L . vardecl fundefs stmts CURLY_BRACKET_R
   20        | CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L . vardecl stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L . vardecl fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L . vardecl CURLY_BRACKET_R
   24        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L . fundefs CURLY_BRACKET_R
   26        | CURLY_BRACKET_L . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    CURLY_BRACKET_R  shift, and go to state 55
    RETURN           shift, and go to state 56
    IF               shift, and go to state 57
    FOR              shift, and go to state 58
    DO               shift, and go to state 59
    WHILE            shift, and go to state 60
    ID               shift, and go to state 61

    fundef   go to state 62
    fundefs  go to state 63
    vardecl  go to state 64
    stmts    go to state 65
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73
    type     go to state 74


state 39

   10 fundef: type ID BRACKET_L param BRACKET_R funbody .

    $default  reduce using rule 10 (fundef)


state 40

   13 param: type ID COMMA . param

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    param  go to state 75
    type   go to state 20


state 41

   11 param: type ID ids . param
   12      | type ID ids .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 12 (param)

    param  go to state 76
    type   go to state 20


state 42

   71 binop: MINUS .

    $default  reduce using rule 71 (binop)


state 43

   70 binop: PLUS .

    $default  reduce using rule 70 (binop)


state 44

   72 binop: STAR .

    $default  reduce using rule 72 (binop)


state 45

   73 binop: SLASH .

    $default  reduce using rule 73 (binop)


state 46

   74 binop: PERCENT .

    $default  reduce using rule 74 (binop)


state 47

   75 binop: LE .

    $default  reduce using rule 75 (binop)


state 48

   76 binop: LT .

    $default  reduce using rule 76 (binop)


state 49

   77 binop: GE .

    $default  reduce using rule 77 (binop)


state 50

   78 binop: GT .

    $default  reduce using rule 78 (binop)


state 51

   79 binop: EQ .

    $default  reduce using rule 79 (binop)


state 52

   80 binop: OR .

    $default  reduce using rule 80 (binop)


state 53

   81 binop: AND .

    $default  reduce using rule 81 (binop)


state 54

   60 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 77
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 55

   26 funbody: CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 26 (funbody)


state 56

   43 return: RETURN . expr SEMICOLON
   44       | RETURN . SEMICOLON

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 78
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 79
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 57

   45 ifelse: IF . BRACKET_L expr BRACKET_R block ELSE block
   46       | IF . BRACKET_L expr BRACKET_R block
   47       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 80


state 58

   51 for: FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR . BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR . BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 81


state 59

   55 doWhile: DO . CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_L  shift, and go to state 82


state 60

   56 while: WHILE . BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 83


state 61

   57 varlet: ID .

    $default  reduce using rule 57 (varlet)


state 62

   15 fundefs: fundef . fundefs
   16        | fundef .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 16 (fundefs)

    fundef   go to state 62
    fundefs  go to state 84
    type     go to state 85


state 63

   20 funbody: CURLY_BRACKET_L fundefs . stmts CURLY_BRACKET_R
   25        | CURLY_BRACKET_L fundefs . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 86
    RETURN           shift, and go to state 56
    IF               shift, and go to state 57
    FOR              shift, and go to state 58
    DO               shift, and go to state 59
    WHILE            shift, and go to state 60
    ID               shift, and go to state 61

    stmts    go to state 87
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 64

   19 funbody: CURLY_BRACKET_L vardecl . fundefs stmts CURLY_BRACKET_R
   21        | CURLY_BRACKET_L vardecl . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl . fundefs CURLY_BRACKET_R
   23        | CURLY_BRACKET_L vardecl . CURLY_BRACKET_R

    INT_TYPE         shift, and go to state 1
    FLOAT_TYPE       shift, and go to state 2
    BOOL_TYPE        shift, and go to state 3
    CURLY_BRACKET_R  shift, and go to state 88
    RETURN           shift, and go to state 56
    IF               shift, and go to state 57
    FOR              shift, and go to state 58
    DO               shift, and go to state 59
    WHILE            shift, and go to state 60
    ID               shift, and go to state 61

    fundef   go to state 62
    fundefs  go to state 89
    stmts    go to state 90
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73
    type     go to state 85


state 65

   24 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 91


state 66

   35 stmts: stmt . stmts
   36      | stmt .

    RETURN  shift, and go to state 56
    IF      shift, and go to state 57
    FOR     shift, and go to state 58
    DO      shift, and go to state 59
    WHILE   shift, and go to state 60
    ID      shift, and go to state 61

    $default  reduce using rule 36 (stmts)

    stmts    go to state 92
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 67

   38 stmt: return .

    $default  reduce using rule 38 (stmt)


state 68

   39 stmt: ifelse .

    $default  reduce using rule 39 (stmt)


state 69

   37 stmt: assign .

    $default  reduce using rule 37 (stmt)


state 70

   40 stmt: for .

    $default  reduce using rule 40 (stmt)


state 71

   41 stmt: doWhile .

    $default  reduce using rule 41 (stmt)


state 72

   42 stmt: while .

    $default  reduce using rule 42 (stmt)


state 73

   50 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 93


state 74

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody
   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 94


state 75

   13 param: type ID COMMA param .

    $default  reduce using rule 13 (param)


state 76

   11 param: type ID ids param .

    $default  reduce using rule 11 (param)


state 77

   60 expr: BRACKET_L expr binop expr . BRACKET_R

    BRACKET_R  shift, and go to state 95


state 78

   44 return: RETURN SEMICOLON .

    $default  reduce using rule 44 (return)


state 79

   43 return: RETURN expr . SEMICOLON

    SEMICOLON  shift, and go to state 96


state 80

   45 ifelse: IF BRACKET_L . expr BRACKET_R block ELSE block
   46       | IF BRACKET_L . expr BRACKET_R block
   47       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 97
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 81

   51 for: FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L . type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L . type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    type  go to state 98


state 82

   55 doWhile: DO CURLY_BRACKET_L . stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    RETURN  shift, and go to state 56
    IF      shift, and go to state 57
    FOR     shift, and go to state 58
    DO      shift, and go to state 59
    WHILE   shift, and go to state 60
    ID      shift, and go to state 61

    stmts    go to state 99
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 83

   56 while: WHILE BRACKET_L . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 100
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 84

   15 fundefs: fundef fundefs .

    $default  reduce using rule 15 (fundefs)


state 85

   10 fundef: type . ID BRACKET_L param BRACKET_R funbody

    ID  shift, and go to state 101


state 86

   25 funbody: CURLY_BRACKET_L fundefs CURLY_BRACKET_R .

    $default  reduce using rule 25 (funbody)


state 87

   20 funbody: CURLY_BRACKET_L fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 102


state 88

   23 funbody: CURLY_BRACKET_L vardecl CURLY_BRACKET_R .

    $default  reduce using rule 23 (funbody)


state 89

   19 funbody: CURLY_BRACKET_L vardecl fundefs . stmts CURLY_BRACKET_R
   22        | CURLY_BRACKET_L vardecl fundefs . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 103
    RETURN           shift, and go to state 56
    IF               shift, and go to state 57
    FOR              shift, and go to state 58
    DO               shift, and go to state 59
    WHILE            shift, and go to state 60
    ID               shift, and go to state 61

    stmts    go to state 104
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 90

   21 funbody: CURLY_BRACKET_L vardecl stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 105


state 91

   24 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 24 (funbody)


state 92

   35 stmts: stmt stmts .

    $default  reduce using rule 35 (stmts)


state 93

   50 assign: varlet LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 106
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 94

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody
   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    BRACKET_L  shift, and go to state 14
    SEMICOLON  shift, and go to state 107
    LET        shift, and go to state 108


state 95

   60 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 60 (expr)


state 96

   43 return: RETURN expr SEMICOLON .

    $default  reduce using rule 43 (return)


state 97

   45 ifelse: IF BRACKET_L expr . BRACKET_R block ELSE block
   46       | IF BRACKET_L expr . BRACKET_R block
   47       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 109


state 98

   51 for: FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type . ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type . ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    ID  shift, and go to state 110


state 99

   55 doWhile: DO CURLY_BRACKET_L stmts . CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON

    CURLY_BRACKET_R  shift, and go to state 111


state 100

   56 while: WHILE BRACKET_L expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 112


state 101

   10 fundef: type ID . BRACKET_L param BRACKET_R funbody

    BRACKET_L  shift, and go to state 14


state 102

   20 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 20 (funbody)


state 103

   22 funbody: CURLY_BRACKET_L vardecl fundefs CURLY_BRACKET_R .

    $default  reduce using rule 22 (funbody)


state 104

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 113


state 105

   21 funbody: CURLY_BRACKET_L vardecl stmts CURLY_BRACKET_R .

    $default  reduce using rule 21 (funbody)


state 106

   50 assign: varlet LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 114


state 107

   34 vardecl: type ID SEMICOLON .

    $default  reduce using rule 34 (vardecl)


state 108

   27 vardecl: type ID LET . exprs expr SEMICOLON vardecl
   28        | type ID LET . exprs expr SEMICOLON
   29        | type ID LET . exprs SEMICOLON vardecl
   30        | type ID LET . expr SEMICOLON vardecl
   31        | type ID LET . exprs SEMICOLON
   32        | type ID LET . expr SEMICOLON
   33        | type ID LET . SEMICOLON vardecl

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 115
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 116
    exprs     go to state 117
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 109

   45 ifelse: IF BRACKET_L expr BRACKET_R . block ELSE block
   46       | IF BRACKET_L expr BRACKET_R . block
   47       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 118

    block  go to state 119


state 110

   51 for: FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID . LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID . LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    LET  shift, and go to state 120


state 111

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R . WHILE BRACKET_L expr BRACKET_R SEMICOLON

    WHILE  shift, and go to state 121


state 112

   56 while: WHILE BRACKET_L expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 122


state 113

   19 funbody: CURLY_BRACKET_L vardecl fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 19 (funbody)


state 114

   50 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 50 (assign)


state 115

   33 vardecl: type ID LET SEMICOLON . vardecl

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    vardecl  go to state 123
    type     go to state 124


state 116

   30 vardecl: type ID LET expr . SEMICOLON vardecl
   32        | type ID LET expr . SEMICOLON
   61 exprs: expr .
   62      | expr . exprs

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 125
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    BRACKET_L  [reduce using rule 61 (exprs)]
    SEMICOLON  [reduce using rule 61 (exprs)]
    TRUEVAL    [reduce using rule 61 (exprs)]
    FALSEVAL   [reduce using rule 61 (exprs)]
    NUM        [reduce using rule 61 (exprs)]
    FLOAT      [reduce using rule 61 (exprs)]
    ID         [reduce using rule 61 (exprs)]

    expr      go to state 126
    exprs     go to state 127
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 117

   27 vardecl: type ID LET exprs . expr SEMICOLON vardecl
   28        | type ID LET exprs . expr SEMICOLON
   29        | type ID LET exprs . SEMICOLON vardecl
   31        | type ID LET exprs . SEMICOLON

    BRACKET_L  shift, and go to state 21
    SEMICOLON  shift, and go to state 128
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 129
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 118

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   49 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 130
    RETURN           shift, and go to state 56
    IF               shift, and go to state 57
    FOR              shift, and go to state 58
    DO               shift, and go to state 59
    WHILE            shift, and go to state 60
    ID               shift, and go to state 61

    stmts    go to state 131
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 119

   45 ifelse: IF BRACKET_L expr BRACKET_R block . ELSE block
   46       | IF BRACKET_L expr BRACKET_R block .

    ELSE  shift, and go to state 132

    $default  reduce using rule 46 (ifelse)


state 120

   51 for: FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET . expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 133
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 121

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE . BRACKET_L expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 134


state 122

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 56
    IF      shift, and go to state 57
    FOR     shift, and go to state 58
    DO      shift, and go to state 59
    WHILE   shift, and go to state 60
    ID      shift, and go to state 61

    stmts    go to state 135
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 123

   33 vardecl: type ID LET SEMICOLON vardecl .

    $default  reduce using rule 33 (vardecl)


state 124

   27 vardecl: type . ID LET exprs expr SEMICOLON vardecl
   28        | type . ID LET exprs expr SEMICOLON
   29        | type . ID LET exprs SEMICOLON vardecl
   30        | type . ID LET expr SEMICOLON vardecl
   31        | type . ID LET exprs SEMICOLON
   32        | type . ID LET expr SEMICOLON
   33        | type . ID LET SEMICOLON vardecl
   34        | type . ID SEMICOLON

    ID  shift, and go to state 136


state 125

   30 vardecl: type ID LET expr SEMICOLON . vardecl
   32        | type ID LET expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 32 (vardecl)]
    FLOAT_TYPE  [reduce using rule 32 (vardecl)]
    BOOL_TYPE   [reduce using rule 32 (vardecl)]
    $default    reduce using rule 32 (vardecl)

    vardecl  go to state 137
    type     go to state 124


state 126

   61 exprs: expr .
   62      | expr . exprs

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    BRACKET_L  [reduce using rule 61 (exprs)]
    TRUEVAL    [reduce using rule 61 (exprs)]
    FALSEVAL   [reduce using rule 61 (exprs)]
    NUM        [reduce using rule 61 (exprs)]
    FLOAT      [reduce using rule 61 (exprs)]
    ID         [reduce using rule 61 (exprs)]
    $default   reduce using rule 61 (exprs)

    expr      go to state 126
    exprs     go to state 127
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 127

   62 exprs: expr exprs .

    $default  reduce using rule 62 (exprs)


state 128

   29 vardecl: type ID LET exprs SEMICOLON . vardecl
   31        | type ID LET exprs SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 31 (vardecl)]
    FLOAT_TYPE  [reduce using rule 31 (vardecl)]
    BOOL_TYPE   [reduce using rule 31 (vardecl)]
    $default    reduce using rule 31 (vardecl)

    vardecl  go to state 138
    type     go to state 124


state 129

   27 vardecl: type ID LET exprs expr . SEMICOLON vardecl
   28        | type ID LET exprs expr . SEMICOLON

    SEMICOLON  shift, and go to state 139


state 130

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   48       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    ELSE  shift, and go to state 140

    $default  reduce using rule 48 (ifelse)


state 131

   49 block: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 141


state 132

   45 ifelse: IF BRACKET_L expr BRACKET_R block ELSE . block

    CURLY_BRACKET_L  shift, and go to state 142

    block  go to state 143


state 133

   51 for: FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr . COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    COMMA  shift, and go to state 144


state 134

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L . expr BRACKET_R SEMICOLON

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 145
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 135

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 146


state 136

   27 vardecl: type ID . LET exprs expr SEMICOLON vardecl
   28        | type ID . LET exprs expr SEMICOLON
   29        | type ID . LET exprs SEMICOLON vardecl
   30        | type ID . LET expr SEMICOLON vardecl
   31        | type ID . LET exprs SEMICOLON
   32        | type ID . LET expr SEMICOLON
   33        | type ID . LET SEMICOLON vardecl
   34        | type ID . SEMICOLON

    SEMICOLON  shift, and go to state 107
    LET        shift, and go to state 108


state 137

   30 vardecl: type ID LET expr SEMICOLON vardecl .

    $default  reduce using rule 30 (vardecl)


state 138

   29 vardecl: type ID LET exprs SEMICOLON vardecl .

    $default  reduce using rule 29 (vardecl)


state 139

   27 vardecl: type ID LET exprs expr SEMICOLON . vardecl
   28        | type ID LET exprs expr SEMICOLON .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    INT_TYPE    [reduce using rule 28 (vardecl)]
    FLOAT_TYPE  [reduce using rule 28 (vardecl)]
    BOOL_TYPE   [reduce using rule 28 (vardecl)]
    $default    reduce using rule 28 (vardecl)

    vardecl  go to state 147
    type     go to state 124


state 140

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 148


state 141

   49 block: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 49 (block)


state 142

   49 block: CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 56
    IF      shift, and go to state 57
    FOR     shift, and go to state 58
    DO      shift, and go to state 59
    WHILE   shift, and go to state 60
    ID      shift, and go to state 61

    stmts    go to state 131
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 143

   45 ifelse: IF BRACKET_L expr BRACKET_R block ELSE block .

    $default  reduce using rule 45 (ifelse)


state 144

   51 for: FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA . expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 149
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 145

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr . BRACKET_R SEMICOLON

    BRACKET_R  shift, and go to state 150


state 146

   56 while: WHILE BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 56 (while)


state 147

   27 vardecl: type ID LET exprs expr SEMICOLON vardecl .

    $default  reduce using rule 27 (vardecl)


state 148

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 151


state 149

   51 for: FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   52    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr . COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 152
    COMMA      shift, and go to state 153


state 150

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R . SEMICOLON

    SEMICOLON  shift, and go to state 154


state 151

   47 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 47 (ifelse)


state 152

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 155


state 153

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 21
    TRUEVAL    shift, and go to state 22
    FALSEVAL   shift, and go to state 23
    NUM        shift, and go to state 24
    FLOAT      shift, and go to state 25
    ID         shift, and go to state 26

    expr      go to state 156
    constant  go to state 28
    floatval  go to state 29
    intval    go to state 30
    boolval   go to state 31


state 154

   55 doWhile: DO CURLY_BRACKET_L stmts CURLY_BRACKET_R WHILE BRACKET_L expr BRACKET_R SEMICOLON .

    $default  reduce using rule 55 (doWhile)


state 155

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   53    | FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 157
    RETURN           shift, and go to state 56
    IF               shift, and go to state 57
    FOR              shift, and go to state 58
    DO               shift, and go to state 59
    WHILE            shift, and go to state 60
    ID               shift, and go to state 61

    stmts    go to state 158
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 156

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 159


state 157

   51 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 51 (for)


state 158

   53 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 160


state 159

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 161


state 160

   53 for: FOR BRACKET_L type ID LET expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 53 (for)


state 161

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R
   54    | FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 162
    RETURN           shift, and go to state 56
    IF               shift, and go to state 57
    FOR              shift, and go to state 58
    DO               shift, and go to state 59
    WHILE            shift, and go to state 60
    ID               shift, and go to state 61

    stmts    go to state 163
    stmt     go to state 66
    return   go to state 67
    ifelse   go to state 68
    assign   go to state 69
    for      go to state 70
    doWhile  go to state 71
    while    go to state 72
    varlet   go to state 73


state 162

   52 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 52 (for)


state 163

   54 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 164


state 164

   54 for: FOR BRACKET_L type ID LET expr COMMA expr COMMA expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 54 (for)
