Useless nonterminals

   exprs


Terminals which are not used

   COMMA
   NE
   INTTYPE
   FLOATTYPE
   BOOLTYPE


Useless rules

   46 exprs: expr
   47      | expr exprs


Grammar

    0 $accept: program $end

    1 program: decls

    2 decls: decl
    3      | decl decls

    4 decl: fundef

    5 fundef: type ID BRACKET_L BRACKET_R funbody

    6 fundefs: fundef fundefs
    7        | fundef

    8 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R
    9        | CURLY_BRACKET_L stmts CURLY_BRACKET_R

   10 stmts: stmt stmts
   11      | stmt

   12 stmt: assign
   13     | return
   14     | ifelse

   15 return: RETURN expr SEMICOLON

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   17       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   18       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

   19 assign: varlet LET expr SEMICOLON

   20 varlet: ID

   21 expr: constant
   22     | ID
   23     | BRACKET_L expr binop expr BRACKET_R

   24 constant: floatval
   25         | intval
   26         | boolval

   27 floatval: FLOAT

   28 intval: NUM

   29 boolval: TRUEVAL
   30        | FALSEVAL

   31 binop: PLUS
   32      | MINUS
   33      | STAR
   34      | SLASH
   35      | PERCENT
   36      | LE
   37      | LT
   38      | GE
   39      | GT
   40      | EQ
   41      | OR
   42      | AND

   43 type: INT_TYPE
   44     | FLOAT_TYPE
   45     | BOOL_TYPE


Terminals, with rules where they appear

$end (0) 0
error (256)
INT_TYPE (258) 43
FLOAT_TYPE (259) 44
BOOL_TYPE (260) 45
BRACKET_L (261) 5 16 17 18 23
BRACKET_R (262) 5 16 17 18 23
COMMA (263)
SEMICOLON (264) 15 19
MINUS (265) 32
PLUS (266) 31
STAR (267) 33
SLASH (268) 34
PERCENT (269) 35
LE (270) 36
LT (271) 37
GE (272) 38
GT (273) 39
EQ (274) 40
NE (275)
OR (276) 41
AND (277) 42
TRUEVAL (278) 29
FALSEVAL (279) 30
LET (280) 19
INTTYPE (281)
FLOATTYPE (282)
BOOLTYPE (283)
CURLY_BRACKET_L (284) 8 9 16 17 18
CURLY_BRACKET_R (285) 8 9 16 17 18
RETURN (286) 15
IF (287) 16 17 18
ELSE (288) 16 17
NUM (289) 28
FLOAT (290) 27
ID (291) 5 20 22


Nonterminals, with rules where they appear

$accept (37)
    on left: 0
program (38)
    on left: 1, on right: 0
decls (39)
    on left: 2 3, on right: 1 3
decl (40)
    on left: 4, on right: 2 3
fundef (41)
    on left: 5, on right: 4 6 7
fundefs (42)
    on left: 6 7, on right: 6 8
funbody (43)
    on left: 8 9, on right: 5
stmts (44)
    on left: 10 11, on right: 8 9 10 16
stmt (45)
    on left: 12 13 14, on right: 10 11
return (46)
    on left: 15, on right: 13
ifelse (47)
    on left: 16 17 18, on right: 14
assign (48)
    on left: 19, on right: 12
varlet (49)
    on left: 20, on right: 19
expr (50)
    on left: 21 22 23, on right: 15 16 17 18 19 23
constant (51)
    on left: 24 25 26, on right: 21
floatval (52)
    on left: 27, on right: 24
intval (53)
    on left: 28, on right: 25
boolval (54)
    on left: 29 30, on right: 26
binop (55)
    on left: 31 32 33 34 35 36 37 38 39 40 41 42, on right: 23
type (56)
    on left: 43 44 45, on right: 5


state 0

    0 $accept: . program $end

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    program  go to state 4
    decls    go to state 5
    decl     go to state 6
    fundef   go to state 7
    type     go to state 8


state 1

   43 type: INT_TYPE .

    $default  reduce using rule 43 (type)


state 2

   44 type: FLOAT_TYPE .

    $default  reduce using rule 44 (type)


state 3

   45 type: BOOL_TYPE .

    $default  reduce using rule 45 (type)


state 4

    0 $accept: program . $end

    $end  shift, and go to state 9


state 5

    1 program: decls .

    $default  reduce using rule 1 (program)


state 6

    2 decls: decl .
    3      | decl . decls

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 2 (decls)

    decls   go to state 10
    decl    go to state 6
    fundef  go to state 7
    type    go to state 8


state 7

    4 decl: fundef .

    $default  reduce using rule 4 (decl)


state 8

    5 fundef: type . ID BRACKET_L BRACKET_R funbody

    ID  shift, and go to state 11


state 9

    0 $accept: program $end .

    $default  accept


state 10

    3 decls: decl decls .

    $default  reduce using rule 3 (decls)


state 11

    5 fundef: type ID . BRACKET_L BRACKET_R funbody

    BRACKET_L  shift, and go to state 12


state 12

    5 fundef: type ID BRACKET_L . BRACKET_R funbody

    BRACKET_R  shift, and go to state 13


state 13

    5 fundef: type ID BRACKET_L BRACKET_R . funbody

    CURLY_BRACKET_L  shift, and go to state 14

    funbody  go to state 15


state 14

    8 funbody: CURLY_BRACKET_L . fundefs stmts CURLY_BRACKET_R
    9        | CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3
    RETURN      shift, and go to state 16
    IF          shift, and go to state 17
    ID          shift, and go to state 18

    fundef   go to state 19
    fundefs  go to state 20
    stmts    go to state 21
    stmt     go to state 22
    return   go to state 23
    ifelse   go to state 24
    assign   go to state 25
    varlet   go to state 26
    type     go to state 8


state 15

    5 fundef: type ID BRACKET_L BRACKET_R funbody .

    $default  reduce using rule 5 (fundef)


state 16

   15 return: RETURN . expr SEMICOLON

    BRACKET_L  shift, and go to state 27
    TRUEVAL    shift, and go to state 28
    FALSEVAL   shift, and go to state 29
    NUM        shift, and go to state 30
    FLOAT      shift, and go to state 31
    ID         shift, and go to state 32

    expr      go to state 33
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37


state 17

   16 ifelse: IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   17       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   18       | IF . BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 38


state 18

   20 varlet: ID .

    $default  reduce using rule 20 (varlet)


state 19

    6 fundefs: fundef . fundefs
    7        | fundef .

    INT_TYPE    shift, and go to state 1
    FLOAT_TYPE  shift, and go to state 2
    BOOL_TYPE   shift, and go to state 3

    $default  reduce using rule 7 (fundefs)

    fundef   go to state 19
    fundefs  go to state 39
    type     go to state 8


state 20

    8 funbody: CURLY_BRACKET_L fundefs . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 16
    IF      shift, and go to state 17
    ID      shift, and go to state 18

    stmts   go to state 40
    stmt    go to state 22
    return  go to state 23
    ifelse  go to state 24
    assign  go to state 25
    varlet  go to state 26


state 21

    9 funbody: CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 41


state 22

   10 stmts: stmt . stmts
   11      | stmt .

    RETURN  shift, and go to state 16
    IF      shift, and go to state 17
    ID      shift, and go to state 18

    $default  reduce using rule 11 (stmts)

    stmts   go to state 42
    stmt    go to state 22
    return  go to state 23
    ifelse  go to state 24
    assign  go to state 25
    varlet  go to state 26


state 23

   13 stmt: return .

    $default  reduce using rule 13 (stmt)


state 24

   14 stmt: ifelse .

    $default  reduce using rule 14 (stmt)


state 25

   12 stmt: assign .

    $default  reduce using rule 12 (stmt)


state 26

   19 assign: varlet . LET expr SEMICOLON

    LET  shift, and go to state 43


state 27

   23 expr: BRACKET_L . expr binop expr BRACKET_R

    BRACKET_L  shift, and go to state 27
    TRUEVAL    shift, and go to state 28
    FALSEVAL   shift, and go to state 29
    NUM        shift, and go to state 30
    FLOAT      shift, and go to state 31
    ID         shift, and go to state 32

    expr      go to state 44
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37


state 28

   29 boolval: TRUEVAL .

    $default  reduce using rule 29 (boolval)


state 29

   30 boolval: FALSEVAL .

    $default  reduce using rule 30 (boolval)


state 30

   28 intval: NUM .

    $default  reduce using rule 28 (intval)


state 31

   27 floatval: FLOAT .

    $default  reduce using rule 27 (floatval)


state 32

   22 expr: ID .

    $default  reduce using rule 22 (expr)


state 33

   15 return: RETURN expr . SEMICOLON

    SEMICOLON  shift, and go to state 45


state 34

   21 expr: constant .

    $default  reduce using rule 21 (expr)


state 35

   24 constant: floatval .

    $default  reduce using rule 24 (constant)


state 36

   25 constant: intval .

    $default  reduce using rule 25 (constant)


state 37

   26 constant: boolval .

    $default  reduce using rule 26 (constant)


state 38

   16 ifelse: IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   17       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   18       | IF BRACKET_L . expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_L  shift, and go to state 27
    TRUEVAL    shift, and go to state 28
    FALSEVAL   shift, and go to state 29
    NUM        shift, and go to state 30
    FLOAT      shift, and go to state 31
    ID         shift, and go to state 32

    expr      go to state 46
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37


state 39

    6 fundefs: fundef fundefs .

    $default  reduce using rule 6 (fundefs)


state 40

    8 funbody: CURLY_BRACKET_L fundefs stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 47


state 41

    9 funbody: CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 9 (funbody)


state 42

   10 stmts: stmt stmts .

    $default  reduce using rule 10 (stmts)


state 43

   19 assign: varlet LET . expr SEMICOLON

    BRACKET_L  shift, and go to state 27
    TRUEVAL    shift, and go to state 28
    FALSEVAL   shift, and go to state 29
    NUM        shift, and go to state 30
    FLOAT      shift, and go to state 31
    ID         shift, and go to state 32

    expr      go to state 48
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37


state 44

   23 expr: BRACKET_L expr . binop expr BRACKET_R

    MINUS    shift, and go to state 49
    PLUS     shift, and go to state 50
    STAR     shift, and go to state 51
    SLASH    shift, and go to state 52
    PERCENT  shift, and go to state 53
    LE       shift, and go to state 54
    LT       shift, and go to state 55
    GE       shift, and go to state 56
    GT       shift, and go to state 57
    EQ       shift, and go to state 58
    OR       shift, and go to state 59
    AND      shift, and go to state 60

    binop  go to state 61


state 45

   15 return: RETURN expr SEMICOLON .

    $default  reduce using rule 15 (return)


state 46

   16 ifelse: IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   17       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   18       | IF BRACKET_L expr . BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R

    BRACKET_R  shift, and go to state 62


state 47

    8 funbody: CURLY_BRACKET_L fundefs stmts CURLY_BRACKET_R .

    $default  reduce using rule 8 (funbody)


state 48

   19 assign: varlet LET expr . SEMICOLON

    SEMICOLON  shift, and go to state 63


state 49

   32 binop: MINUS .

    $default  reduce using rule 32 (binop)


state 50

   31 binop: PLUS .

    $default  reduce using rule 31 (binop)


state 51

   33 binop: STAR .

    $default  reduce using rule 33 (binop)


state 52

   34 binop: SLASH .

    $default  reduce using rule 34 (binop)


state 53

   35 binop: PERCENT .

    $default  reduce using rule 35 (binop)


state 54

   36 binop: LE .

    $default  reduce using rule 36 (binop)


state 55

   37 binop: LT .

    $default  reduce using rule 37 (binop)


state 56

   38 binop: GE .

    $default  reduce using rule 38 (binop)


state 57

   39 binop: GT .

    $default  reduce using rule 39 (binop)


state 58

   40 binop: EQ .

    $default  reduce using rule 40 (binop)


state 59

   41 binop: OR .

    $default  reduce using rule 41 (binop)


state 60

   42 binop: AND .

    $default  reduce using rule 42 (binop)


state 61

   23 expr: BRACKET_L expr binop . expr BRACKET_R

    BRACKET_L  shift, and go to state 27
    TRUEVAL    shift, and go to state 28
    FALSEVAL   shift, and go to state 29
    NUM        shift, and go to state 30
    FLOAT      shift, and go to state 31
    ID         shift, and go to state 32

    expr      go to state 64
    constant  go to state 34
    floatval  go to state 35
    intval    go to state 36
    boolval   go to state 37


state 62

   16 ifelse: IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   17       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   18       | IF BRACKET_L expr BRACKET_R . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 65


state 63

   19 assign: varlet LET expr SEMICOLON .

    $default  reduce using rule 19 (assign)


state 64

   23 expr: BRACKET_L expr binop expr . BRACKET_R

    BRACKET_R  shift, and go to state 66


state 65

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R
   17       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   18       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 67
    RETURN           shift, and go to state 16
    IF               shift, and go to state 17
    ID               shift, and go to state 18

    stmts   go to state 68
    stmt    go to state 22
    return  go to state 23
    ifelse  go to state 24
    assign  go to state 25
    varlet  go to state 26


state 66

   23 expr: BRACKET_L expr binop expr BRACKET_R .

    $default  reduce using rule 23 (expr)


state 67

   17 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R . ELSE CURLY_BRACKET_L CURLY_BRACKET_R
   18       | IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R .

    ELSE  shift, and go to state 69

    $default  reduce using rule 18 (ifelse)


state 68

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts . CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 70


state 69

   17 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE . CURLY_BRACKET_L CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 71


state 70

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R . ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R

    ELSE  shift, and go to state 72


state 71

   17 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 73


state 72

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE . CURLY_BRACKET_L stmts CURLY_BRACKET_R

    CURLY_BRACKET_L  shift, and go to state 74


state 73

   17 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L CURLY_BRACKET_R ELSE CURLY_BRACKET_L CURLY_BRACKET_R .

    $default  reduce using rule 17 (ifelse)


state 74

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L . stmts CURLY_BRACKET_R

    RETURN  shift, and go to state 16
    IF      shift, and go to state 17
    ID      shift, and go to state 18

    stmts   go to state 75
    stmt    go to state 22
    return  go to state 23
    ifelse  go to state 24
    assign  go to state 25
    varlet  go to state 26


state 75

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts . CURLY_BRACKET_R

    CURLY_BRACKET_R  shift, and go to state 76


state 76

   16 ifelse: IF BRACKET_L expr BRACKET_R CURLY_BRACKET_L stmts CURLY_BRACKET_R ELSE CURLY_BRACKET_L stmts CURLY_BRACKET_R .

    $default  reduce using rule 16 (ifelse)
